
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>cwhSReachSet</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-11-30"><meta name="DC.source" content="cwhSReachSet.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Verification of satellite rendezvous problem via SReachSet</a></li><li><a href="#2">Problem formulation: Spacecraft motion via CWH dynamics</a></li><li><a href="#4">Dynamics model for the deputy relative to the chief spacecraft</a></li><li><a href="#5">System definition</a></li><li><a href="#6">Methods to run</a></li><li><a href="#7">Target tube construction --- reach-avoid specification</a></li><li><a href="#9">Preparation for set computation</a></li><li><a href="#10">CC (Linear program approach)</a></li><li><a href="#11">Fourier transform (Genz's algorithm and MATLAB's patternsearch)</a></li><li><a href="#12">Lagrangian approach</a></li><li><a href="#13">Preparation for Monte-Carlo simulations of the optimal controllers</a></li><li><a href="#14">Plotting and Monte-Carlo simulation-based validation</a></li><li><a href="#15">Reporting solution times</a></li><li><a href="#16">Helper functions</a></li></ul></div><h2 id="1">Verification of satellite rendezvous problem via SReachSet</h2><p>This example will demonstrate the use of SReachTools in verification of stochastic continuous-state discrete-time linear time-invariant (LTI) systems.</p><p>Specifically, we will discuss how SReachTools can use Fourier transforms (<a href="http://www.math.wsu.edu/faculty/genz/software/matlab/qsimvnv.m">Genz's algorithm</a> and MATLAB's patternsearch), convex chance constraints, and Lagrangian methods to construct underapproximative stochastic reach sets.</p><p>Our approaches is grid-free and recursion-free resulting in highly scalable solutions, especially for Gaussian-perturbed LTI systems.</p><p>This Live Script is part of the SReachTools toolbox. License for the use of this function is given in <a href="https://github.com/unm-hscl/SReachTools/blob/master/LICENSE">https://github.com/unm-hscl/SReachTools/blob/master/LICENSE</a>.</p><pre class="codeinput"><span class="comment">% Prescript running: Initializing srtinit, if it already hasn't been initialized</span>
close <span class="string">all</span>;clearvars;srtinit;srtinit <span class="string">--version</span>;
</pre><pre class="codeoutput">SReachTools version 1.2.26
</pre><h2 id="2">Problem formulation: Spacecraft motion via CWH dynamics</h2><p>We consider both the spacecrafts, referred to as the deputy spacecraft and the chief spacecraft, to be in the same circular orbit. In this example, we will consider the problem of verification for the spacecraft rendezvous problem, i.e., identify all the initial states from which the deputy can can rendezvous with the chief while staying within the line-of-sight cone with a likelihood above a user-specified threshold.</p><p><img vspace="5" hspace="5" src="cwh_sketch.png" alt=""> </p><h2 id="4">Dynamics model for the deputy relative to the chief spacecraft</h2><p>The relative planar dynamics of the deputy with respect to the chief are described by the <a href="https://doi.org/10.1109/CDC.2013.6760626">Clohessy-Wiltshire-Hill (CWH) equations,</a></p><p><img src="cwhSReachSet_eq00898161790449768620.png" alt="$$\ddot{x} - 3 \omega x - 2 \omega \dot{y} = \frac{F_{x}}{m_{d}}$$"></p><p><img src="cwhSReachSet_eq15283232495949856112.png" alt="$$            \ddot{y} + 2 \omega \dot{x} = \frac{F_{y}}{m_{d}}$$"></p><p>where the position of the deputy relative to the chief is <img src="cwhSReachSet_eq15556242510480314522.png" alt="$x,y \in \mathbf{R}$">, <img src="cwhSReachSet_eq07285538383886324120.png" alt="$\omega = \sqrt{\frac{\mu}{R_{0}^{3}}}$"> is the orbital frequency, <img src="cwhSReachSet_eq05371638286043275527.png" alt="$\mu$"> is the gravitational constant, and <img src="cwhSReachSet_eq10871390185993502494.png" alt="$R_{0}$"> is the orbital radius of the chief spacecraft.  We define the state as <img src="cwhSReachSet_eq10872751811371042055.png" alt="$\overline{x} = {[x\ y\ \dot{x}\ \dot{y}]}^\top \in \mathbf{R}^{4}$"> which is the position and velocity of the deputy relative to the chief along <img src="cwhSReachSet_eq15238746908345155538.png" alt="$\mathrm{x}$">- and <img src="cwhSReachSet_eq06683332128004049953.png" alt="$\mathrm{y}$">- axes, and the input as <img src="cwhSReachSet_eq03681831066756660658.png" alt="$\overline{u} = {[F_{x}\ F_{y}]}^\top \in \mathcal{U}\subset\mathbf{R}^{2}$">.</p><p>We will discretize the CWH dynamics in time, via zero-order hold, to obtain the discrete-time linear time-invariant system and add a Gaussian disturbance to account for the modeling uncertainties and the disturbance forces,</p><p><img src="cwhSReachSet_eq17824561326300448854.png" alt="$$\overline{x}_{k+1} = A \overline{x}_{k} + B \overline{u}_{k} +&#xA;\overline{w}_{k}$$"></p><p>with <img src="cwhSReachSet_eq17592557756310175309.png" alt="$\overline{w}_{k} \in \mathbf{R}^{4}$"> as an IID Gaussian zero-mean random process with a known covariance matrix <img src="cwhSReachSet_eq13715931348400830039.png" alt="$\Sigma_{\overline{w}}$">.</p><h2 id="5">System definition</h2><pre class="codeinput">umax = 0.1;
mean_disturbance = zeros(4,1);
covariance_disturbance = diag([1e-4, 1e-4, 5e-8, 5e-8]);
<span class="comment">% Define the CWH (planar) dynamics of the deputy spacecraft relative to the</span>
<span class="comment">% chief spacecraft as a LtiSystem object</span>
sys = getCwhLtiSystem(4, Polyhedron(<span class="string">'lb'</span>, -umax*ones(2,1), <span class="keyword">...</span>
                                    <span class="string">'ub'</span>,  umax*ones(2,1)), <span class="keyword">...</span>
       RandomVector(<span class="string">'Gaussian'</span>, mean_disturbance,covariance_disturbance));
</pre><h2 id="6">Methods to run</h2><pre class="codeinput">ft_run = 0;
cc_open_run = 0;
lagunder_run = 1;
</pre><h2 id="7">Target tube construction --- reach-avoid specification</h2><pre class="codeinput">time_horizon = 5;          <span class="comment">% Stay within a line of sight cone for 4 time steps and</span>
                         <span class="comment">% reach the target at t=5% Safe Set --- LoS cone</span>
<span class="comment">% Safe set definition --- LoS cone |x|&lt;=y and y\in[0,ymax] and |vx|&lt;=vxmax and</span>
<span class="comment">% |vy|&lt;=vymax</span>
ymax = 2;
vxmax = 0.5;
vymax = 0.5;
A_safe_set = [1, 1, 0, 0;
             -1, 1, 0, 0;
              0, -1, 0, 0;
              0, 0, 1,0;
              0, 0,-1,0;
              0, 0, 0,1;
              0, 0, 0,-1];
b_safe_set = [0;
              0;
              ymax;
              vxmax;
              vxmax;
              vymax;
              vymax];
safe_set = Polyhedron(A_safe_set, b_safe_set);
<span class="comment">% Target set --- Box [-0.1,0.1]x[-0.1,0]x[-0.01,0.01]x[-0.01,0.01]</span>
target_set = Polyhedron(<span class="string">'lb'</span>, [-0.1; -0.1; -0.01; -0.01], <span class="keyword">...</span>
                        <span class="string">'ub'</span>, [0.1; 0; 0.01; 0.01]);
target_tube = Tube(<span class="string">'reach-avoid'</span>,safe_set, target_set, time_horizon);
slice_at_vx_vy = zeros(2,1);
</pre><h2 id="9">Preparation for set computation</h2><pre class="codeinput">prob_thresh = 0.8;

n_dir_vecs = 10;
theta_vec = linspace(0, 2*pi, n_dir_vecs);
set_of_dir_vecs_ft = [cos(theta_vec);
                      sin(theta_vec);
                      zeros(2,n_dir_vecs)];
n_dir_vecs = 40;
theta_vec = linspace(0, 2*pi, n_dir_vecs);
set_of_dir_vecs_cc_open = [cos(theta_vec);
                           sin(theta_vec);
                           zeros(2,n_dir_vecs)];
init_safe_set_affine = Polyhedron(<span class="string">'He'</span>,[zeros(2,2) eye(2,2) slice_at_vx_vy]);
</pre><h2 id="10">CC (Linear program approach)</h2><pre class="codeinput"><span class="keyword">if</span> cc_open_run
    cc_options = SReachSetOptions(<span class="string">'term'</span>, <span class="string">'chance-open'</span>, <span class="keyword">...</span>
        <span class="string">'set_of_dir_vecs'</span>, set_of_dir_vecs_cc_open, <span class="keyword">...</span>
        <span class="string">'init_safe_set_affine'</span>, init_safe_set_affine, <span class="keyword">...</span>
        <span class="string">'verbose'</span>, 0);
    timer_cc_open = tic;
    [polytope_cc_open, extra_info] = SReachSet(<span class="string">'term'</span>,<span class="string">'chance-open'</span>, sys, <span class="keyword">...</span>
        prob_thresh, target_tube, cc_options);
    elapsed_time_cc_open = toc(timer_cc_open);
<span class="keyword">end</span>
</pre><h2 id="11">Fourier transform (Genz's algorithm and MATLAB's patternsearch)</h2><pre class="codeinput"><span class="keyword">if</span> ft_run
    ft_options = SReachSetOptions(<span class="string">'term'</span>, <span class="string">'genzps-open'</span>, <span class="keyword">...</span>
        <span class="string">'set_of_dir_vecs'</span>, set_of_dir_vecs_ft, <span class="keyword">...</span>
        <span class="string">'init_safe_set_affine'</span>, init_safe_set_affine, <span class="string">'verbose'</span>, 1);
    timer_ft = tic;
    polytope_ft = SReachSet(<span class="string">'term'</span>,<span class="string">'genzps-open'</span>, sys, prob_thresh, <span class="keyword">...</span>
        target_tube, ft_options);
    elapsed_time_ft = toc(timer_ft);
<span class="keyword">end</span>
</pre><h2 id="12">Lagrangian approach</h2><pre class="codeinput"><span class="keyword">if</span> lagunder_run
    n_dim = sys.state_dim + sys.input_dim;
    lag_options = SReachSetOptions(<span class="string">'term'</span>, <span class="string">'lag-under'</span>, <span class="string">'bound_set_method'</span>, <span class="keyword">...</span>
         <span class="string">'ellipsoid'</span>, <span class="string">'system'</span>, sys, <span class="string">'verbose'</span>, 2,<span class="keyword">...</span>
         <span class="string">'n_underapprox_vertices'</span>, 2^n_dim * 6 + 2*n_dim);

    timer_lagunder = tic;
    polytope_lagunder = SReachSet(<span class="string">'term'</span>, <span class="string">'lag-under'</span>, sys,  prob_thresh, <span class="keyword">...</span>
        target_tube, lag_options);
    elapsed_time_lagunder = toc(timer_lagunder);
<span class="keyword">end</span>
</pre><pre class="codeoutput">Spreading 396 unit-length vectors in 6-dim space
Analyzing 6 unit-length vectors in first quadrant
 1. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 1.714e-10 (&lt; 1.000e-08)
Change in opt cost: 4.805e-01 (&lt; 1.000e-05)

 2. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 4.884e-10 (&lt; 1.000e-08)
Change in opt cost: 9.621e-02 (&lt; 1.000e-05)

 3. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 2.715e-10 (&lt; 1.000e-08)
Change in opt cost: 2.791e-02 (&lt; 1.000e-05)

 4. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 1.310e-10 (&lt; 1.000e-08)
Change in opt cost: 3.099e-03 (&lt; 1.000e-05)

 5. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 1.048e-11 (&lt; 1.000e-08)
Change in opt cost: 1.167e-05 (&lt; 1.000e-05)

 6. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 2.593e-12 (&lt; 1.000e-08)
Change in opt cost: 8.216e-09 (&lt; 1.000e-05)

Completed spreading the vectors!
Time to spread the vectors: 16.882 s

Computing Lagragian under approximation
Time_horizon: 5

Computation for time step: 4
Time to setup x_u_reaches_target_set: 0.006 s
Time for MVE computation: 0.774 s
Time to get v-rep underapprox.: 0.059 s
Time to get H-rep underapprox.: 5.440 s
Time for oneStepBack: 6.303 s

Computation for time step: 3
Time to setup x_u_reaches_target_set: 0.003 s
Time for MVE computation: 1.850 s
Time to get v-rep underapprox.: 0.066 s
Time to get H-rep underapprox.: 6.595 s
Time for oneStepBack: 8.526 s

Computation for time step: 2
Time to setup x_u_reaches_target_set: 0.003 s
Time for MVE computation: 2.001 s
Time to get v-rep underapprox.: 0.064 s
Time to get H-rep underapprox.: 7.316 s
Time for oneStepBack: 9.396 s

Computation for time step: 1
Time to setup x_u_reaches_target_set: 0.005 s
Time for MVE computation: 2.621 s
Time to get v-rep underapprox.: 0.073 s
Time to get H-rep underapprox.: 7.366 s
Time for oneStepBack: 10.081 s

Computation for time step: 0
Time to setup x_u_reaches_target_set: 0.004 s
Time for MVE computation: 2.081 s
Time to get v-rep underapprox.: 0.066 s
Time to get H-rep underapprox.: 1.884 s
Time for oneStepBack: 4.049 s
</pre><h2 id="13">Preparation for Monte-Carlo simulations of the optimal controllers</h2><p>Monte-Carlo simulation parameters</p><pre class="codeinput">n_mcarlo_sims = 1e5;
n_sims_to_plot = 5;
</pre><h2 id="14">Plotting and Monte-Carlo simulation-based validation</h2><pre class="codeinput">figure(101);
clf
box <span class="string">on</span>;
hold <span class="string">on</span>;
plot(safe_set.slice([3,4], slice_at_vx_vy), <span class="string">'color'</span>, <span class="string">'y'</span>);
plot(target_set.slice([3,4], slice_at_vx_vy), <span class="string">'color'</span>, <span class="string">'g'</span>);
legend_cell = {<span class="string">'Safe set'</span>,<span class="string">'Target set'</span>};
<span class="keyword">if</span> cc_open_run &amp;&amp; ~isEmptySet(polytope_cc_open)
    plot(Polyhedron(<span class="string">'V'</span>,polytope_cc_open.V(:,1:2)), <span class="string">'color'</span>,<span class="string">'k'</span>,<span class="string">'alpha'</span>,0.5);
    legend_cell{end+1} = <span class="string">'Underapprox. polytope (chance-open)'</span>;
<span class="keyword">else</span>
    polytope_cc_open = Polyhedron();
    elapsed_time_cc_open = NaN;
<span class="keyword">end</span>
<span class="keyword">if</span> ft_run &amp;&amp; ~isEmptySet(polytope_ft)
    plot(Polyhedron(<span class="string">'V'</span>,polytope_ft.V(:,1:2)), <span class="string">'color'</span>,<span class="string">'b'</span>,<span class="string">'alpha'</span>,0.5);
    legend_cell{end+1} = <span class="string">'Underapprox. polytope (genzps-open)'</span>;
<span class="keyword">else</span>
    polytope_ft = Polyhedron();
    elapsed_time_ft = NaN;
<span class="keyword">end</span>
<span class="keyword">if</span> lagunder_run &amp;&amp; ~isEmptySet(polytope_lagunder)
    plot(Polyhedron(<span class="string">'V'</span>,polytope_lagunder.V(:,1:2)), <span class="string">'color'</span>,<span class="string">'r'</span>,<span class="string">'alpha'</span>,0.5);
    legend_cell{end+1} = <span class="string">'Underapprox. polytope (lag-under)'</span>;
<span class="keyword">else</span>
    polytope_lagunder = Polyhedron();
    elapsed_time_lagunder = NaN;
<span class="keyword">end</span>
direction_index_to_plot = 30;
<span class="keyword">if</span> ~isEmptySet(polytope_cc_open)
    init_state = extra_info(2).vertices_underapprox_polytope(:,direction_index_to_plot);
    input_vec = extra_info(2).opt_input_vec_at_vertices(:,direction_index_to_plot);
    opt_reach_avoid = extra_info(2).opt_reach_prob_i(direction_index_to_plot);

    concat_state_realization = generateMonteCarloSims(<span class="keyword">...</span>
            n_mcarlo_sims, <span class="keyword">...</span>
            sys, <span class="keyword">...</span>
            init_state, <span class="keyword">...</span>
            time_horizon, <span class="keyword">...</span>
            input_vec);

    <span class="comment">% Check if the location is within the target_set or not</span>
    mcarlo_result = target_tube.contains(concat_state_realization);
    [legend_cell] = plotMonteCarlo(<span class="string">' (chance-open)'</span>, mcarlo_result, <span class="keyword">...</span>
        concat_state_realization, n_mcarlo_sims, n_sims_to_plot, <span class="keyword">...</span>
        sys.state_dim, init_state, legend_cell);
    fprintf(<span class="string">'Expected probability: %1.3f, Simulated probability: %1.3f\n'</span>,<span class="keyword">...</span>
        opt_reach_avoid, sum(mcarlo_result)/n_mcarlo_sims);

<span class="keyword">end</span>
legend(legend_cell, <span class="string">'Location'</span>,<span class="string">'South'</span>);
xlabel(<span class="string">'$x$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
ylabel(<span class="string">'$y$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
</pre><img vspace="5" hspace="5" src="cwhSReachSet_01.png" alt=""> <h2 id="15">Reporting solution times</h2><pre class="codeinput"><span class="keyword">if</span> any(isnan([elapsed_time_ft, elapsed_time_cc_open, elapsed_time_lagunder]))
    disp(<span class="string">'Skipped items would show up as NaN'</span>);
<span class="keyword">end</span>
fprintf([<span class="string">'Elapsed time: (genzps-open) %1.3f | (chance-open) %1.3f'</span>,<span class="keyword">...</span>
    <span class="string">' | (lag-under) %1.3f seconds\n'</span>], <span class="keyword">...</span>
    elapsed_time_ft, elapsed_time_cc_open, elapsed_time_lagunder);
</pre><pre class="codeoutput">Skipped items would show up as NaN
Elapsed time: (genzps-open) NaN | (chance-open) NaN | (lag-under) 38.415 seconds
</pre><h2 id="16">Helper functions</h2><p>Plotting function</p><pre class="codeinput"><span class="keyword">function</span> [legend_cell] = plotMonteCarlo(method_str, mcarlo_result, <span class="keyword">...</span>
    concat_state_realization, n_mcarlo_sims, n_sims_to_plot, state_dim, <span class="keyword">...</span>
    initial_state, legend_cell)
<span class="comment">% Plots a selection of Monte-Carlo simulations on top of the plot</span>

    green_legend_updated = 0;
    red_legend_updated = 0;
    traj_indices = floor(n_mcarlo_sims*rand(1,n_sims_to_plot));
    <span class="keyword">for</span> realization_index = traj_indices
        <span class="comment">% Check if the trajectory satisfies the reach-avoid objective</span>
        <span class="keyword">if</span> mcarlo_result(realization_index)
            <span class="comment">% Assign green triangle as the marker</span>
            markerString = <span class="string">'g^-'</span>;
        <span class="keyword">else</span>
            <span class="comment">% Assign red asterisk as the marker</span>
            markerString = <span class="string">'r*-'</span>;
        <span class="keyword">end</span>
        <span class="comment">% Create [x(t_1) x(t_2)... x(t_N)]</span>
        reshaped_X_vector = reshape(<span class="keyword">...</span>
            concat_state_realization(:,realization_index), state_dim,[]);
        <span class="comment">% This realization is to be plotted</span>
        h = plot([initial_state(1), reshaped_X_vector(1,:)], <span class="keyword">...</span>
                 [initial_state(2), reshaped_X_vector(2,:)], <span class="keyword">...</span>
                 markerString, <span class="string">'MarkerSize'</span>,10);
        <span class="comment">% Update the legends if the first else, disable</span>
        <span class="keyword">if</span> strcmp(markerString,<span class="string">'g^-'</span>)
            <span class="keyword">if</span> green_legend_updated
                h.Annotation.LegendInformation.IconDisplayStyle = <span class="string">'off'</span>;
            <span class="keyword">else</span>
                green_legend_updated = 1;
                legend_cell{end+1} = strcat(<span class="string">'Good trajectory '</span>, method_str);
            <span class="keyword">end</span>
        <span class="keyword">elseif</span> strcmp(markerString,<span class="string">'r*-'</span>)
            <span class="keyword">if</span> red_legend_updated
                h.Annotation.LegendInformation.IconDisplayStyle = <span class="string">'off'</span>;
            <span class="keyword">else</span>
                red_legend_updated = 1;
                legend_cell{end+1} = strcat(<span class="string">'Bad trajectory '</span>, method_str);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Verification of satellite rendezvous problem via SReachSet 
% This example will demonstrate the use of SReachTools in verification of
% stochastic continuous-state discrete-time linear time-invariant (LTI) systems.
% 
% Specifically, we will discuss how SReachTools can use Fourier transforms
% (<http://www.math.wsu.edu/faculty/genz/software/matlab/qsimvnv.m Genz's
% algorithm> and MATLAB's patternsearch), convex chance constraints, and
% Lagrangian methods to construct underapproximative stochastic reach sets.
%
% Our approaches is grid-free and recursion-free resulting in highly scalable
% solutions, especially for Gaussian-perturbed LTI systems. 
%
% This Live Script is part of the SReachTools toolbox. License for the use of
% this function is given in
% <https://github.com/unm-hscl/SReachTools/blob/master/LICENSE
% https://github.com/unm-hscl/SReachTools/blob/master/LICENSE>.

% Prescript running: Initializing srtinit, if it already hasn't been initialized
close all;clearvars;srtinit;srtinit REPLACE_WITH_DASH_DASHversion;

%% Problem formulation: Spacecraft motion via CWH dynamics
% We consider both the spacecrafts, referred to as the deputy spacecraft and 
% the chief spacecraft, to be in the same circular orbit. In this example, we 
% will consider the problem of verification for the spacecraft rendezvous
% problem, i.e., identify all the initial states from which the deputy can can
% rendezvous with the chief while staying within the line-of-sight cone with
% a likelihood above a user-specified threshold.
%%
% <<cwh_sketch.png>>
%% Dynamics model for the deputy relative to the chief spacecraft 
% The relative planar dynamics of the deputy with respect to the chief are
% described by the <https://doi.org/10.1109/CDC.2013.6760626
% Clohessy-Wiltshire-Hill (CWH) equations,> 
% 
% $$\ddot{x} - 3 \omega x - 2 \omega \dot{y} = \frac{F_{x}}{m_{d}}$$
% 
% $$            \ddot{y} + 2 \omega \dot{x} = \frac{F_{y}}{m_{d}}$$ 
% 
% where the position of the deputy relative to the chief is $x,y \in
% \mathbf{R}$, $\omega = \sqrt{\frac{\mu}{R_{0}^{3}}}$ is the orbital frequency,
% $\mu$ is the gravitational constant, and $R_{0}$ is the orbital radius of the
% chief spacecraft.  We define the state as $\overline{x} = {[x\ y\ \dot{x}\
% \dot{y}]}^\top \in \mathbf{R}^{4}$ which is the position and velocity of the
% deputy relative to the chief along $\mathrm{x}$- and $\mathrm{y}$- axes, and
% the input as $\overline{u} = {[F_{x}\ F_{y}]}^\top \in
% \mathcal{U}\subset\mathbf{R}^{2}$. 
% 
% We will discretize the CWH dynamics in time, via zero-order hold, to obtain
% the discrete-time linear time-invariant system and add a Gaussian disturbance
% to account for the modeling uncertainties and the disturbance forces,
% 
% $$\overline{x}_{k+1} = A \overline{x}_{k} + B \overline{u}_{k} +
% \overline{w}_{k}$$
% 
% with $\overline{w}_{k} \in \mathbf{R}^{4}$ as an IID Gaussian zero-mean 
% random process with a known covariance matrix $\Sigma_{\overline{w}}$. 
 
%% System definition
umax = 0.1;
mean_disturbance = zeros(4,1);
covariance_disturbance = diag([1e-4, 1e-4, 5e-8, 5e-8]);
% Define the CWH (planar) dynamics of the deputy spacecraft relative to the
% chief spacecraft as a LtiSystem object
sys = getCwhLtiSystem(4, Polyhedron('lb', -umax*ones(2,1), ...
                                    'ub',  umax*ones(2,1)), ...
       RandomVector('Gaussian', mean_disturbance,covariance_disturbance));

%% Methods to run   
ft_run = 0;
cc_open_run = 0;
lagunder_run = 1;
%% Target tube construction REPLACE_WITH_DASH_DASH- reach-avoid specification
time_horizon = 5;          % Stay within a line of sight cone for 4 time steps and 
                         % reach the target at t=5% Safe Set REPLACE_WITH_DASH_DASH- LoS cone
% Safe set definition REPLACE_WITH_DASH_DASH- LoS cone |x|<=y and y\in[0,ymax] and |vx|<=vxmax and 
% |vy|<=vymax
ymax = 2;
vxmax = 0.5;
vymax = 0.5;
A_safe_set = [1, 1, 0, 0;           
             -1, 1, 0, 0; 
              0, -1, 0, 0;
              0, 0, 1,0;
              0, 0,-1,0;
              0, 0, 0,1;
              0, 0, 0,-1];
b_safe_set = [0;
              0;
              ymax;
              vxmax;
              vxmax;
              vymax;
              vymax];
safe_set = Polyhedron(A_safe_set, b_safe_set);
% Target set REPLACE_WITH_DASH_DASH- Box [-0.1,0.1]x[-0.1,0]x[-0.01,0.01]x[-0.01,0.01]
target_set = Polyhedron('lb', [-0.1; -0.1; -0.01; -0.01], ...
                        'ub', [0.1; 0; 0.01; 0.01]);
target_tube = Tube('reach-avoid',safe_set, target_set, time_horizon);                    
slice_at_vx_vy = zeros(2,1);
%%

%% Preparation for set computation
prob_thresh = 0.8;

n_dir_vecs = 10;
theta_vec = linspace(0, 2*pi, n_dir_vecs);
set_of_dir_vecs_ft = [cos(theta_vec);
                      sin(theta_vec);
                      zeros(2,n_dir_vecs)];
n_dir_vecs = 40;
theta_vec = linspace(0, 2*pi, n_dir_vecs);
set_of_dir_vecs_cc_open = [cos(theta_vec);
                           sin(theta_vec);
                           zeros(2,n_dir_vecs)];
init_safe_set_affine = Polyhedron('He',[zeros(2,2) eye(2,2) slice_at_vx_vy]);

%% CC (Linear program approach)
if cc_open_run
    cc_options = SReachSetOptions('term', 'chance-open', ...
        'set_of_dir_vecs', set_of_dir_vecs_cc_open, ...
        'init_safe_set_affine', init_safe_set_affine, ...
        'verbose', 0);
    timer_cc_open = tic;
    [polytope_cc_open, extra_info] = SReachSet('term','chance-open', sys, ...
        prob_thresh, target_tube, cc_options);  
    elapsed_time_cc_open = toc(timer_cc_open);
end

%% Fourier transform (Genz's algorithm and MATLAB's patternsearch)
if ft_run
    ft_options = SReachSetOptions('term', 'genzps-open', ...
        'set_of_dir_vecs', set_of_dir_vecs_ft, ...
        'init_safe_set_affine', init_safe_set_affine, 'verbose', 1);
    timer_ft = tic;
    polytope_ft = SReachSet('term','genzps-open', sys, prob_thresh, ...
        target_tube, ft_options);  
    elapsed_time_ft = toc(timer_ft);
end

%% Lagrangian approach
if lagunder_run
    n_dim = sys.state_dim + sys.input_dim;
    lag_options = SReachSetOptions('term', 'lag-under', 'bound_set_method', ...
         'ellipsoid', 'system', sys, 'verbose', 2,...
         'n_underapprox_vertices', 2^n_dim * 6 + 2*n_dim);
    
    timer_lagunder = tic;
    polytope_lagunder = SReachSet('term', 'lag-under', sys,  prob_thresh, ...
        target_tube, lag_options);
    elapsed_time_lagunder = toc(timer_lagunder);
end


%% Preparation for Monte-Carlo simulations of the optimal controllers
% Monte-Carlo simulation parameters
n_mcarlo_sims = 1e5;
n_sims_to_plot = 5;

%% Plotting and Monte-Carlo simulation-based validation
figure(101);
clf
box on;
hold on;
plot(safe_set.slice([3,4], slice_at_vx_vy), 'color', 'y');
plot(target_set.slice([3,4], slice_at_vx_vy), 'color', 'g');
legend_cell = {'Safe set','Target set'};
if cc_open_run && ~isEmptySet(polytope_cc_open)
    plot(Polyhedron('V',polytope_cc_open.V(:,1:2)), 'color','k','alpha',0.5);
    legend_cell{end+1} = 'Underapprox. polytope (chance-open)';
else
    polytope_cc_open = Polyhedron();
    elapsed_time_cc_open = NaN;
end
if ft_run && ~isEmptySet(polytope_ft)
    plot(Polyhedron('V',polytope_ft.V(:,1:2)), 'color','b','alpha',0.5);
    legend_cell{end+1} = 'Underapprox. polytope (genzps-open)';
else
    polytope_ft = Polyhedron();
    elapsed_time_ft = NaN;
end
if lagunder_run && ~isEmptySet(polytope_lagunder)
    plot(Polyhedron('V',polytope_lagunder.V(:,1:2)), 'color','r','alpha',0.5);    
    legend_cell{end+1} = 'Underapprox. polytope (lag-under)';
else
    polytope_lagunder = Polyhedron();
    elapsed_time_lagunder = NaN;
end
direction_index_to_plot = 30;
if ~isEmptySet(polytope_cc_open)
    init_state = extra_info(2).vertices_underapprox_polytope(:,direction_index_to_plot);
    input_vec = extra_info(2).opt_input_vec_at_vertices(:,direction_index_to_plot);
    opt_reach_avoid = extra_info(2).opt_reach_prob_i(direction_index_to_plot);

    concat_state_realization = generateMonteCarloSims(...
            n_mcarlo_sims, ...
            sys, ...
            init_state, ...
            time_horizon, ...
            input_vec);        
    
    % Check if the location is within the target_set or not
    mcarlo_result = target_tube.contains(concat_state_realization);
    [legend_cell] = plotMonteCarlo(' (chance-open)', mcarlo_result, ...
        concat_state_realization, n_mcarlo_sims, n_sims_to_plot, ...
        sys.state_dim, init_state, legend_cell);
    fprintf('Expected probability: %1.3f, Simulated probability: %1.3f\n',...
        opt_reach_avoid, sum(mcarlo_result)/n_mcarlo_sims);

end
legend(legend_cell, 'Location','South');
xlabel('$x$','interpreter','latex');
ylabel('$y$','interpreter','latex');

%% Reporting solution times
if any(isnan([elapsed_time_ft, elapsed_time_cc_open, elapsed_time_lagunder]))
    disp('Skipped items would show up as NaN');
end
fprintf(['Elapsed time: (genzps-open) %1.3f | (chance-open) %1.3f',...
    ' | (lag-under) %1.3f seconds\n'], ...
    elapsed_time_ft, elapsed_time_cc_open, elapsed_time_lagunder);

%% Helper functions
% Plotting function
function [legend_cell] = plotMonteCarlo(method_str, mcarlo_result, ...
    concat_state_realization, n_mcarlo_sims, n_sims_to_plot, state_dim, ...
    initial_state, legend_cell)
% Plots a selection of Monte-Carlo simulations on top of the plot

    green_legend_updated = 0;
    red_legend_updated = 0;
    traj_indices = floor(n_mcarlo_sims*rand(1,n_sims_to_plot));
    for realization_index = traj_indices
        % Check if the trajectory satisfies the reach-avoid objective
        if mcarlo_result(realization_index)
            % Assign green triangle as the marker
            markerString = 'g^-';
        else
            % Assign red asterisk as the marker
            markerString = 'r*-';
        end
        % Create [x(t_1) x(t_2)... x(t_N)]
        reshaped_X_vector = reshape(...
            concat_state_realization(:,realization_index), state_dim,[]);
        % This realization is to be plotted
        h = plot([initial_state(1), reshaped_X_vector(1,:)], ...
                 [initial_state(2), reshaped_X_vector(2,:)], ...
                 markerString, 'MarkerSize',10);
        % Update the legends if the first else, disable
        if strcmp(markerString,'g^-')
            if green_legend_updated
                h.Annotation.LegendInformation.IconDisplayStyle = 'off';
            else
                green_legend_updated = 1;
                legend_cell{end+1} = strcat('Good trajectory ', method_str);
            end
        elseif strcmp(markerString,'r*-')
            if red_legend_updated
                h.Annotation.LegendInformation.IconDisplayStyle = 'off';
            else
                red_legend_updated = 1;
                legend_cell{end+1} = strcat('Bad trajectory ', method_str);
            end
        end
    end
end

##### SOURCE END #####
--></body></html>