function [boundary_theta, ...
          boundary_inputs, ...
          boundary_reach_avoid_prob] = computeBoundaryPointViaBisection(...
                                      xmax, ...
                                      direction, ...
                                      max_underapprox_reach_avoid_prob, ...
                                      optimal_input_vector_for_xmax, ...
                                      lower_bound_on_optimal_theta, ...
                                      upper_bound_on_optimal_theta, ...
                                      tolerance_bisection, ...
                                      prob_threshold, ...
                                      sys, ...
                                      time_horizon, ...
                                      concat_input_space_A, ... 
                                      concat_input_space_b, ...
                                      concat_target_tube_A, ... 
                                      concat_target_tube_b, ...
                                      H, ...
                                      Abar, ...
                                      mean_X_sans_input_sans_initial_state, ...
                                      cov_X_sans_input, ...
                                      desired_accuracy, ...
                                      PSoptions)
% SReachTools/stochasticReachAvoid/computeBoundaryPointViaBisection: Compute via
% bisection them maximum extension of a ray starting from xmax and the
% associated optimal open-loop controller and maximum reach-avoid probability
% (Internal function --- assumes arguments are all ok)
% =============================================================================
%
% computeBoundaryPointViaBisection extends a ray originating from xmax as long
% as possible while being above a given prob_threshold. This
% function is useful in computing a polytopic underapproximation of the
% stochastic reach-avoid set in
% getFtBasedUnderapproxStochReachAvoidSet.
%
% USAGE: See getFtBasedUnderapproxStochReachAvoidSet.
%
% =============================================================================
%
% [boundary_theta, ...
%          boundary_inputs, ...
%          boundary_reach_avoid_prob] = computeBoundaryPointViaBisection(...
%                           xmax, ...
%                           direction, ...
%                           max_underapprox_reach_avoid_prob, ...
%                           optimal_input_vector_for_xmax, ...
%                           lower_bound_on_optimal_theta, ...
%                           upper_bound_on_optimal_theta, ...
%                           tolerance_bisection, ...
%                           prob_threshold, ...
%                           sys, ...
%                           time_horizon, ...
%                           concat_input_space_A, ... 
%                           concat_input_space_b, ...
%                           concat_target_tube_A, ... 
%                           concat_target_tube_b, ...
%                           H, ...
%                           Abar, ...
%                           mean_X_sans_input_sans_initial_state, ...
%                           cov_X_sans_input, ...
%                           desired_accuracy, ...
%                           PSoptions)
% 
% Inputs:
% -------
%  xmax                         - Initial state that has the maximum attainable
%                                 stochastic reach-avoid probability using an
%                                 open-loop controller
%  direction                    - Direction that needs to be explored for
%                                 computing the polytope
%  max_underapprox_reach_avoid_prob
%                               - Maximum attainable stochastic reach-avoid
%                                 probability using an open-loop controller
%  optimal_input_vector_for_xmax- Optimal input vector for xmax
%  lower_bound_on_optimal_theta - Lower bound on the theta extension (zero
%                                 typically since xmax is guaranteed to be
%                                 within the polytope)
%  upper_bound_on_optimal_theta - Upper bound on the theta extension (maybe
%                                 computed via an LP for polytopic reach-avoid
%                                 tube)
%  tolerance_bisection          - Bisection tolerance for the computation of the
%                                 extension [Use 1e-2 if unsure]
%  prob_threshold
%                               - Probability threshold (a) that defines the
%                                 stochastic reach-avoid set of interest 
%                                 {x_0: V_0^\ast(x_0) \geq a}
%  sys                          - LtiSystem object describing the system to be
%                                 verified
%  time_horizon                 - Time horizon of the stochastic reach-avoid
%                                 problem
%  concat_input_space_A,  
%   concat_input_space_b        - (A,b) Halfspace representation for the
%                                 polytope U^{time_horizon} set.        
%  concat_target_tube_A,  
%   concat_target_tube_b        - (A,b) Halfspace representation for the
%                                 target tube. For example, the terminal
%                                 reach-avoid problem requires a polytope of the
%                                 form safe_set^{time_horizon-1} x target_set.        
%  H                            - Concatenated input matrix
%  Abar                         - Concatenated state matrix (see
%                                 @LtiSystem/getConcatMats for the
%                                 notation used in next three inputs)
%  mean_X_sans_input_sans_initial_state
%                               - Mean of X w\ zero input under the disturbance
%  cov_X_sans_input             - Covariance of X w\ zero input under the
%                                 disturbance
%  desired_accuracy             - Accuracy expected for the integral of the
%                                 Gaussian random vector X over the
%                                 concatenated_target_tube
%  PSoptions                    - Options for patternsearch 
%
% Outputs:
% --------
%  boundary_theta               - Maximum extension that can be done (theta)
%  boundary_inputs              - Associated optimal open-loop controller
%  boundary_reach_avoid_prob    - Associated maximum stochastic reach-avoid
%                                 probability
%
% Notes:
% * NOT ACTIVELY TESTED: TODO
% * NO INPUT HANDLING: For computational speed. To be used via
%   getFtBasedUnderapproxStochReachAvoidSet
% * MATLAB DEPENDENCY: Uses MATLAB's Global Optimization Toolbox; Statistics and
%                      Machine Learning Toolbox.
%                      Needs patternsearch for gradient-free optimization
%                      Needs normpdf, normcdf, norminv for Genz's algorithm
% * Uses computeFtLowerBoundStochReachAvoid to compute the
%   actual stochastic reach-avoid underapproximation
% 
% =============================================================================
% 
% This function is part of the Stochastic Reachability Toolbox.
% License for the use of this function is given in
%      https://github.com/abyvinod/SReachTools/blob/master/LICENSE
%
%


    % Initialize the outputs so that if bisection doesn't happen, we get
    % meaningful answers
    optimal_theta_so_far = 0;
    optimal_reachAvoid_probability_so_far = ...
                               max_underapprox_reach_avoid_prob;
    optimal_inputs_so_far = optimal_input_vector_for_xmax;

    %% Bisection begins if the gap is above tolerance_bisection
    if (upper_bound_on_optimal_theta - lower_bound_on_optimal_theta) >...
                                                             tolerance_bisection
        fprintf(['OptRAProb | OptTheta | LB_theta | UB_theta | OptInp^2', ...  
                 ' | Exit reason\n']);               % 10 characters between | |

        % While the gap remains above tolerance_bisection
        while (upper_bound_on_optimal_theta - lower_bound_on_optimal_theta)>...
                                                             tolerance_bisection
            % Set phi as the middle point of the interval
            phi = (upper_bound_on_optimal_theta+lower_bound_on_optimal_theta)/2;
            % Set initial guess for patternsearch as optimal_inputs_so_far
            initial_guess_for_input_vector = optimal_inputs_so_far;
            % Candidate initial state provides mean_X_sans_input
            % See @LtiSystem/getConcatMats for notation
            candidate_initial_state = xmax + phi * direction;
            mean_X_sans_input = Abar * candidate_initial_state + ...
                                    mean_X_sans_input_sans_initial_state;
            % Compute the maximum reach-avoid probability and the associated
            % open-loop optimal controller starting from candidate_initial_state
            [optimal_reachAvoid_probability_at_this_step, ...
             optimal_input_at_this_step] = ...
                       computeFtLowerBoundStochReachAvoid(...
                                                  sys, ...
                                                  candidate_initial_state, ...
                                                  time_horizon, ...
                                                  concat_input_space_A, ...
                                                  concat_input_space_b, ...
                                                  concat_target_tube_A, ...
                                                  concat_target_tube_b, ...
                                                  H, ...
                                                  mean_X_sans_input, ...
                                                  cov_X_sans_input, ...
                                                  optimal_inputs_so_far, ...
                                                  desired_accuracy, ...
                                                  PSoptions);

            if optimal_reachAvoid_probability_at_this_step >= ...
                                               prob_threshold
                % Update theta to phi only if it is above the threshold
                optimal_inputs_so_far = optimal_input_at_this_step;
                optimal_theta_so_far = phi;
                optimal_reachAvoid_probability_so_far = ...
                                optimal_reachAvoid_probability_at_this_step;
                exitmessage = ' Feasible';
            else
                % Update nothing since patternsearch failed to converge
                exitmessage = ' Infeasible';
            end
            % Print current solution
            fprintf(strcat(...
                '  %1.4f  |  %1.4f  |  %1.4f  |  %1.4f  |  %1.4f  |  ', ...
                exitmessage, ...
                ' \n'), ...
                       optimal_reachAvoid_probability_so_far, ...
                       optimal_theta_so_far, ...
                       lower_bound_on_optimal_theta, ...
                       upper_bound_on_optimal_theta, ...
                       optimal_inputs_so_far'*optimal_inputs_so_far);

            % Update bounds
            if optimal_reachAvoid_probability_at_this_step >= ...
                                               prob_threshold
                % Theta proved to be feasible
                lower_bound_on_optimal_theta = phi;
            else
                % Shrink the upper bound
                upper_bound_on_optimal_theta = phi;
            end
        end        
    else
        fprintf(['###Skipping bisection since theta interval too small! ', ...
                 'Returning the initial guess!\n']);
    end
    boundary_inputs = optimal_inputs_so_far;
    boundary_reach_avoid_prob = optimal_reachAvoid_probability_so_far;
    boundary_theta = optimal_theta_so_far;
end
