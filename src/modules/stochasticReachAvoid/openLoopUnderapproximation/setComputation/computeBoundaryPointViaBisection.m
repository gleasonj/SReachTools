function [boundary_theta,...
          boundary_inputs,...
          boundary_reach_avoid_prob] = computeBoundaryPointViaBisection(...
                            xmax,...
                            direction,...
                            maximum_underapproximate_reach_avoid_probability,...
                            optimal_input_vector_for_xmax,...
                            lower_bound_on_optimal_theta,...
                            upper_bound_on_optimal_theta,...
                            tolerance_bisection,...
                            probability_threshold_of_interest,...
                            sys,...
                            time_horizon,...
                            concatenated_input_space_A,... 
                            concatenated_input_space_b,...
                            concatenated_target_tube_A,... 
                            concatenated_target_tube_b,...
                            H_matrix,...
                            Abar,...
                            mean_X_sans_input_sans_initial_state,...
                            covariance_X_sans_input,...
                            desired_accuracy,...
                            PSoptions)
% SReach/stochasticReachAvoid/computeBoundaryPointViaBisection: Compute via
% bisection them maximum extension of a ray starting from xmax and the
% associated optimal open-loop controller and maximum reach-avoid probability
% (Internal function --- assumes arguments are all ok)
% =============================================================================
%
% computeBoundaryPointViaBisection extends a ray originating from xmax as long
% as possible while being above a given probability_threshold_of_interest. This
% function is useful in computing a polytopic underapproximation of the
% stochastic reach-avoid set in
% getFtBasedUnderapproximateStochasticReachAvoidSet.
%
% USAGE: See getFtBasedUnderapproximateStochasticReachAvoidSet.
%
% =============================================================================
%
% [boundary_theta,...
%          boundary_inputs,...
%          boundary_reach_avoid_prob] = computeBoundaryPointViaBisection(...
%                           xmax,...
%                           direction,...
%                           maximum_underapproximate_reach_avoid_probability,...
%                           optimal_input_vector_for_xmax,...
%                           lower_bound_on_optimal_theta,...
%                           upper_bound_on_optimal_theta,...
%                           tolerance_bisection,...
%                           probability_threshold_of_interest,...
%                           sys,...
%                           time_horizon,...
%                           concatenated_input_space_A,... 
%                           concatenated_input_space_b,...
%                           concatenated_target_tube_A,... 
%                           concatenated_target_tube_b,...
%                           H_matrix,...
%                           Abar,...
%                           mean_X_sans_input_sans_initial_state,...
%                           covariance_X_sans_input,...
%                           desired_accuracy,...
%                           PSoptions)
% 
% Inputs:
% -------
%  xmax                         - Initial state that has the maximum attainable
%                                 stochastic reach-avoid probability using an
%                                 open-loop controller
%  direction                    - Direction that needs to be explored for
%                                 computing the polytope
%  maximum_underapproximate_reach_avoid_probability
%                               - Maximum attainable stochastic reach-avoid
%                                 probability using an open-loop controller
%  optimal_input_vector_for_xmax- Optimal input vector for xmax
%  lower_bound_on_optimal_theta - Lower bound on the theta extension (zero
%                                 typically since xmax is guaranteed to be
%                                 within the polytope)
%  upper_bound_on_optimal_theta - Upper bound on the theta extension (maybe
%                                 computed via an LP for polytopic reach-avoid
%                                 tube)
%  tolerance_bisection          - Bisection tolerance for the computation of the
%                                 extension [Use 1e-2 if unsure]
%  probability_threshold_of_interest
%                               - Probability threshold (a) that defines the
%                                 stochastic reach-avoid set of interest 
%                                 {x_0: V_0^\ast(x_0) \geq a}
%  sys                          - LtiSystem object describing the system to be
%                                 verified
%  time_horizon                 - Time horizon of the stochastic reach-avoid
%                                 problem
%  concatenated_input_space_A,  
%   concatenated_input_space_b  - (A,b) Halfspace representation for the
%                                 polytope U^{time_horizon} set.        
%  concatenated_target_tube_A,  
%   concatenated_target_tube_b  - (A,b) Halfspace representation for the
%                                 target tube. For example, the terminal
%                                 reach-avoid problem requires a polytope of the
%                                 form safe_set^{time_horizon-1} x target_set.        
%  H_matrix                     - Concatenated input matrix
%  Abar                         - Concatenated state matrix (see
%                                 @LtiSystem/getConcatMats for the
%                                 notation used in next three inputs)
%  mean_X_sans_input_sans_initial_state
%                               - Mean of X w\ zero input under the disturbance
%  covariance_X_sans_input      - Covariance of X w\ zero input under the
%                                 disturbance
%  desired_accuracy             - Accuracy expected for the integral of the
%                                 Gaussian random vector X over the
%                                 concatenated_target_tube
%  PSoptions                    - Options for patternsearch 
%
% Outputs:
% --------
%  boundary_theta               - Maximum extension that can be done (theta)
%  boundary_inputs              - Associated optimal open-loop controller
%  boundary_reach_avoid_prob    - Associated maximum stochastic reach-avoid
%                                 probability
%
% Notes:
% * NOT ACTIVELY TESTED: TODO
% * NO INPUT HANDLING: For computational speed. To be used via
%   getFtBasedUnderapproximateStochasticReachAvoidSet
% * MATLAB DEPENDENCY: Uses MATLAB's Global Optimization Toolbox; Statistics and
%                      Machine Learning Toolbox.
%                      Needs patternsearch for gradient-free optimization
%                      Needs normpdf, normcdf, norminv for Genz's algorithm
% * Uses computeFtLowerBoundStochasticReachAvoid to compute the
%   actual stochastic reach-avoid underapproximation
% 
% =============================================================================
% 
% This function is part of the Stochastic Optimal Control Toolbox.
% License for the use of this function is given in
%      https://github.com/abyvinod/SReach/blob/master/LICENSE
%
%


    % Initialize the outputs so that if bisection doesn't happen, we get
    % meaningful answers
    optimal_theta_so_far = 0;
    optimal_reachAvoid_probability_so_far =...
                               maximum_underapproximate_reach_avoid_probability;
    optimal_inputs_so_far = optimal_input_vector_for_xmax;

    %% Bisection begins if the gap is above tolerance_bisection
    if (upper_bound_on_optimal_theta - lower_bound_on_optimal_theta) >...
                                                             tolerance_bisection
        fprintf(['OptRAProb | OptTheta | LB_theta | UB_theta | OptInp^2',...  
                 ' | Exit reason\n']);               % 10 characters between | |

        % While the gap remains above tolerance_bisection
        while (upper_bound_on_optimal_theta - lower_bound_on_optimal_theta)>...
                                                             tolerance_bisection
            % Set phi as the middle point of the interval
            phi = (upper_bound_on_optimal_theta+lower_bound_on_optimal_theta)/2;
            % Set initial guess for patternsearch as optimal_inputs_so_far
            initial_guess_for_input_vector = optimal_inputs_so_far;
            % Candidate initial state provides mean_X_sans_input
            % See @LtiSystem/getConcatMats for notation
            candidate_initial_state = xmax + phi * direction;
            mean_X_sans_input = Abar * candidate_initial_state + ...
                                    mean_X_sans_input_sans_initial_state;
            % Compute the maximum reach-avoid probability and the associated
            % open-loop optimal controller starting from candidate_initial_state
            [optimal_reachAvoid_probability_at_this_step,...
             optimal_input_at_this_step] =...
                       computeFtLowerBoundStochasticReachAvoid(...
                                                  sys,...
                                                  candidate_initial_state,...
                                                  time_horizon,...
                                                  concatenated_input_space_A,...
                                                  concatenated_input_space_b,...
                                                  concatenated_target_tube_A,...
                                                  concatenated_target_tube_b,...
                                                  H_matrix,...
                                                  mean_X_sans_input,...
                                                  covariance_X_sans_input,...
                                                  optimal_inputs_so_far,...
                                                  desired_accuracy,...
                                                  PSoptions);

            if optimal_reachAvoid_probability_at_this_step >=...
                                               probability_threshold_of_interest
                % Update theta to phi only if it is above the threshold
                optimal_inputs_so_far = optimal_input_at_this_step;
                optimal_theta_so_far = phi;
                optimal_reachAvoid_probability_so_far =...
                                optimal_reachAvoid_probability_at_this_step;
                exitmessage = ' Feasible';
            else
                % Update nothing since patternsearch failed to converge
                exitmessage = ' Infeasible';
            end
            % Print current solution
            fprintf(strcat(...
                '  %1.4f  |  %1.4f  |  %1.4f  |  %1.4f  |  %1.4f  |  ',...
                exitmessage,...
                ' \n'),...
                       optimal_reachAvoid_probability_so_far,...
                       optimal_theta_so_far,...
                       lower_bound_on_optimal_theta,...
                       upper_bound_on_optimal_theta,...
                       optimal_inputs_so_far'*optimal_inputs_so_far);

            % Update bounds
            if optimal_reachAvoid_probability_at_this_step >=...
                                               probability_threshold_of_interest
                % Theta proved to be feasible
                lower_bound_on_optimal_theta = phi;
            else
                % Shrink the upper bound
                upper_bound_on_optimal_theta = phi;
            end
        end        
    else
        fprintf(['###Skipping bisection since theta interval too small! ',...
                 'Returning the initial guess!\n']);
    end
    boundary_inputs = optimal_inputs_so_far;
    boundary_reach_avoid_prob = optimal_reachAvoid_probability_so_far;
    boundary_theta = optimal_theta_so_far;
end
