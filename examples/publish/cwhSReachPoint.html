
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>cwhSReachPoint</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-11-30"><meta name="DC.source" content="cwhSReachPoint.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Controller synthesis using <tt>SReachPoint</tt> for a spacecraft rendezvous problem</a></li><li><a href="#2">Problem formulation: Stochastic reachability of a target tube</a></li><li><a href="#4">Dynamics model for the deputy relative to the chief spacecraft</a></li><li><a href="#5">Target tube definition</a></li><li><a href="#6">Specifying initial states and which options to run</a></li><li><a href="#7">Quantities needed to compute the optimal mean trajectory and Monte-Carlo sims</a></li><li><a href="#8"><tt>SReachPoint</tt>: <tt>chance-open</tt></a></li><li><a href="#9"><tt>SReachPoint</tt>: <tt>genzps-open</tt></a></li><li><a href="#10"><tt>SReachPoint</tt>: <tt>particle-open</tt></a></li><li><a href="#11"><tt>SReachPoint</tt>: <tt>voronoi-open</tt></a></li><li><a href="#12"><tt>SReachPoint</tt>: <tt>chance-affine</tt></a></li><li><a href="#13"><tt>SReachPoint</tt>: <tt>voronoi-affine</tt></a></li><li><a href="#14">Summary of results</a></li></ul></div><h2 id="1">Controller synthesis using <tt>SReachPoint</tt> for a spacecraft rendezvous problem</h2><p>This example will demonstrate the use of <tt>SReachTools</tt> for controller synthesis in a stochastic continuous-state discrete-time linear time-invariant (LTI) systems. This example script is part of the <tt>SReachTools</tt> toolbox, which is licensed under GPL v3 or (at your option) any later version. A copy of this license is given in <a href="https://github.com/unm-hscl/SReachTools/blob/master/LICENSE">https://github.com/unm-hscl/SReachTools/blob/master/LICENSE</a>.</p><p>In this example script, we discuss how to use <tt>SReachPoint</tt> to synthesize open-loop controllers and affine-disturbance feedback controllers for the problem of stochastic reachability of a target tube. We demonstrate the following solution techniques:</p><div><ul><li><tt>chance-open</tt>: Chance-constrained approach that uses risk allocation and    piecewise-affine approximations to formulate a linear program to    synthesize an open-loop controller (See    <a href="http://hscl.unm.edu/affinecontrollersynthesis">Vinod and Oishi, Hybrid    Systems: Computation and Control, 2019 (submitted)</a>,    <a href="http://doi.org/10.1109/CDC.2013.6760626">Lesser et. al., Conference on    Decision and Control, 2013</a>)</li><li><tt>genzps-open</tt>: Fourier transforms that uses    <a href="http://www.math.wsu.edu/faculty/genz/software/matlab/qsimvnv.m">Genz's    algorithm</a> to formulate a nonlinear log-concave optimization problem to be    solved using MATLAB's patternsearch to synthesize an open-loop controller    (See <a href="http://doi.org/10.1109/LCSYS.2017.2716364">Vinod and Oishi, Control    System Society- Letters, 2017</a>)</li><li><tt>particle-open</tt>: Particle control filter approach that formulates a    mixed-integer linear program to synthesize an open-loop controller (See    <a href="http://doi.org/10.1109/CDC.2013.6760626">Lesser et. al., Conference on    Decision and Control, 2013</a>)</li><li><tt>voronoi-open</tt>: Particle control filter approach that formulates a    mixed-integer linear program to synthesize an open-loop controller. In    contrast to <tt>particle-open</tt>, <tt>voronoi-open</tt> permits a user-specified upper    bound on the overapproximation error in the maximal reach probability and    has significant computational advantages due to its undersampling approach.    (See <a href="arxiv_link_TODO">Sartipizadeh et. al., American Control Conference,    2019 (submitted)</a>)</li><li><tt>chance-affine</tt>: Chance-constrained approach that uses risk allocation and    piecewise-affine approximations to formulate a difference-of-convex program    to synthesize a closed-loop (affine disturbance feedback) controller.  The    controller synthesis is done by solving a series of second-order cone    programs. (See <a href="http://hscl.unm.edu/affinecontrollersynthesis">Vinod and    Oishi, Hybrid Systems: Computation and Control, 2019 (submitted)</a>)</li></ul></div><p>All computations were performed using MATLAB on an Intel Xeon CPU with 3.4GHz clock rate and 32 GB RAM. The simulation times for individual methods are reported in each section along with a Monte-Carlo simulation validation. The overall simulation time was 2 minutes. For sake of clarity, all commands were asked to be verbose (via SReachPointOptions). In practice, this can be turned off.</p><pre class="codeinput"><span class="comment">% Prescript running: Initializing srtinit, if it already hasn't been initialized</span>
close <span class="string">all</span>;clearvars;srtinit;srtinit <span class="string">--version</span>;
</pre><pre class="codeoutput">SReachTools version 1.2.26
</pre><h2 id="2">Problem formulation: Stochastic reachability of a target tube</h2><p>Given an initial state <img src="cwhSReachPoint_eq00349689335557330151.png" alt="$x_0$">, a time horizon <img src="cwhSReachPoint_eq03672095713503266041.png" alt="$N$">, a linear system dynamics <img src="cwhSReachPoint_eq03953463996820571413.png" alt="$x_{k+1} = A_k x_k + B_k u_k + F w_k$"> for <img src="cwhSReachPoint_eq02387875974568995516.png" alt="$k\in \{0,1,...,N-1\}$">, and a target tube <img src="cwhSReachPoint_eq14998415673510253701.png" alt="${\{\mathcal{T}_k\}}_{k=0}^N$">, we wish to design an admissible controller that maximizes the probability of the state staying with the target tube. This maximal reach probability, denoted by <img src="cwhSReachPoint_eq04637125263344826268.png" alt="$V^\ast(x_0)$">, is obtained by solving the following optimization problem</p><p><img src="cwhSReachPoint_eq15673162868274727063.png" alt="$$ V^\ast(x_0) = \max_{\overline{U}\in \mathcal{U}^N} P^{x_0,&#xA;\overline{U}}_{X} \{ \forall k, x_k \in \mathcal{T}_k\}.$$"></p><p>Here, <img src="cwhSReachPoint_eq09083417299240044346.png" alt="$\overline{U}$"> refers to the control policy which satisfies the control bounds specified by the input space <img src="cwhSReachPoint_eq14976155597326937056.png" alt="$\mathcal{U}$"> over the entire time horizon <img src="cwhSReachPoint_eq03672095713503266041.png" alt="$N$">, <img src="cwhSReachPoint_eq11126846126939553872.png" alt="$X= {[x_1\ x_2\ \ldots\ x_N]}^\top$"> is the concatenated state vector, and the target tube is a sequence of sets <img src="cwhSReachPoint_eq14998415673510253701.png" alt="${\{\mathcal{T}_k\}}_{k=0}^N$">.  Here, <img src="cwhSReachPoint_eq12362013959998143435.png" alt="$X$"> is a random vector with probability measure <img src="cwhSReachPoint_eq10216330609266908820.png" alt="$P^{x_0,\overline{U}}_X$"> which is a parameterized by the initial state <img src="cwhSReachPoint_eq00349689335557330151.png" alt="$x_0$"> and policy <img src="cwhSReachPoint_eq09083417299240044346.png" alt="$\overline{U}$">.</p><p>In the general formulation requires <img src="cwhSReachPoint_eq09083417299240044346.png" alt="$\overline{U}$"> is given by a sequence of (potentially time-varying and nonlinear) state-feedback controllers. To compute such a policy, we have to resort to dynamic programming which suffers from the curse of dimensionality. See these papers for details <a href="https://doi.org/10.1016/j.automatica.2008.03.027">Abate et. al, Automatica, 2008</a>, <a href="https://doi.org/10.1016/j.automatica.2010.08.006">Summers and Lygeros, Automatica, 2010</a>, and <a href="https://arxiv.org/abs/1810.05217">Vinod and Oishi, IEEE Trans. Automatic Control, 2018 (submitted)</a>.</p><p><tt>SReachPoint</tt> provides multiple ways to compute an <b>underapproximation</b> of <img src="cwhSReachPoint_eq04637125263344826268.png" alt="$V^\ast(x_0)$"> by restricting the search to the following controllers:</p><div><ul><li>open-loop controller: The controller provides a sequence of control actions <img src="cwhSReachPoint_eq02166279874784551509.png" alt="$\overline{U}={[u_0\ u_1\ \ldots\ u_{N-1}]}^\top\in \mathcal{U}^N$"> parameterized only by the initial state. This controller does not account for the actual state realization and therefore can be conservative. However, computing this control sequence is easy due to known convexity properties of the problem. See <a href="https://arxiv.org/abs/1810.05217">Vinod and Oishi, IEEE Trans. Automatic Control, 2018 (submitted)</a> for more details.  Apart from <tt>particle-open</tt>, all approaches provide guaranteed underapproximations or underapproximations to a user-specifed error.</li><li>affine-disturbance feedback controller: The controller is a characterized by an affine transformation of the concatenated disturbance vector. The gain matrix is forced to be lower-triangular for the causality, resulting in the control action at <img src="cwhSReachPoint_eq15636846968047188835.png" alt="$k$"> be dependent only the past disturbance values. Here, the control action at time <img src="cwhSReachPoint_eq17944072391318578013.png" alt="$k\in \{0,1,\ldots,N-1\}$"> is given by <img src="cwhSReachPoint_eq11525126879664329771.png" alt="$u_k = \sum_{i=0}^{k-1} M_{ki} w_i + d_k$">.  We optimize for <img src="cwhSReachPoint_eq11123128908060944256.png" alt="$M_{ki}$"> and <img src="cwhSReachPoint_eq11048210160712887941.png" alt="$d_k$"> for every <img src="cwhSReachPoint_eq01303838243332911814.png" alt="$k,i$">, and the controller is given by <img src="cwhSReachPoint_eq18354076366442465445.png" alt="$\overline{U}=MW + d\in \mathcal{U}^N$">, with <img src="cwhSReachPoint_eq14938702097696968401.png" alt="$W=[w_0\ w_1\ \ldots\ w_{N-1}]$"> denoting the concatenated disturbance random vector. By construction, <img src="cwhSReachPoint_eq09083417299240044346.png" alt="$\overline{U}$"> is now random, and it can not satisfy hard control bounds with non-zero <img src="cwhSReachPoint_eq11123128908060944256.png" alt="$M_{ki}$"> and unbounded <img src="cwhSReachPoint_eq14900514129597942148.png" alt="$W$">. Therefore, we relax the control bound constraints <img src="cwhSReachPoint_eq10965413925199845674.png" alt="$\overline{U}\in\mathcal{U}^N$"> to a chance constraint, <img src="cwhSReachPoint_eq06884032053500531429.png" alt="$P_W\{MW + d\in \mathcal{U}^N\}\geq 1-\Delta_U$"> permitting the user to specify the probabilistic violation <img src="cwhSReachPoint_eq01539431133159780657.png" alt="$\Delta_U\in[0,1)$"> of the control bounds. We then construct a lower bound for the maximal reach probability when the affine disturbance feedback controller is used under saturation to meet the hard control bounds. In contrast to the open-loop controller synthesis, affine disturbance feedback controller synthesis is a non-convex problem, and we obtain a locally optimal solution using difference-of-convex programming. See <a href="http://hscl.unm.edu/affinecontrollersynthesis">Vinod and Oishi, Hybrid Systems: Computation and Control, 2019 (submitted)</a> for more details.</li></ul></div><p>All of our approaches are grid-free resulting in highly scalable solutions, especially for Gaussian-perturbed linear systems.</p><p>In this example, we perform controller synthesis that maximizes the probability of a deputy spacecraft to rendezvous with a chief spacecraft while staying within a line-of-sight cone.</p><p><img vspace="5" hspace="5" src="cwh_sketch.png" alt=""> </p><h2 id="4">Dynamics model for the deputy relative to the chief spacecraft</h2><p>We consider both the spacecrafts to be in the same circular orbit. The relative planar dynamics of the deputy with respect to the chief are described by the <a href="https://doi.org/10.1109/CDC.2013.6760626">Clohessy-Wiltshire-Hill (CWH) equations,</a></p><p><img src="cwhSReachPoint_eq00898161790449768620.png" alt="$$\ddot{x} - 3 \omega x - 2 \omega \dot{y} = \frac{F_{x}}{m_{d}}$$"></p><p><img src="cwhSReachPoint_eq15283232495949856112.png" alt="$$            \ddot{y} + 2 \omega \dot{x} = \frac{F_{y}}{m_{d}}$$"></p><p>where the position of the deputy relative to the chief is <img src="cwhSReachPoint_eq15556242510480314522.png" alt="$x,y \in \mathbf{R}$">, <img src="cwhSReachPoint_eq07285538383886324120.png" alt="$\omega = \sqrt{\frac{\mu}{R_{0}^{3}}}$"> is the orbital frequency, <img src="cwhSReachPoint_eq05371638286043275527.png" alt="$\mu$"> is the gravitational constant, and <img src="cwhSReachPoint_eq10871390185993502494.png" alt="$R_{0}$"> is the orbital radius of the chief spacecraft.  We define the state as <img src="cwhSReachPoint_eq10872751811371042055.png" alt="$\overline{x} = {[x\ y\ \dot{x}\ \dot{y}]}^\top \in \mathbf{R}^{4}$"> which is the position and velocity of the deputy relative to the chief along <img src="cwhSReachPoint_eq15238746908345155538.png" alt="$\mathrm{x}$">- and <img src="cwhSReachPoint_eq06683332128004049953.png" alt="$\mathrm{y}$">- axes, and the input as <img src="cwhSReachPoint_eq03681831066756660658.png" alt="$\overline{u} = {[F_{x}\ F_{y}]}^\top \in \mathcal{U}\subset\mathbf{R}^{2}$">.</p><p>We will discretize the CWH dynamics in time, via zero-order hold, to obtain the discrete-time linear time-invariant system and add a Gaussian disturbance to account for the modeling uncertainties and the disturbance forces,</p><p><img src="cwhSReachPoint_eq17824561326300448854.png" alt="$$\overline{x}_{k+1} = A \overline{x}_{k} + B \overline{u}_{k} +&#xA;\overline{w}_{k}$$"></p><p>with <img src="cwhSReachPoint_eq17592557756310175309.png" alt="$\overline{w}_{k} \in \mathbf{R}^{4}$"> as an IID Gaussian zero-mean random process with a known covariance matrix <img src="cwhSReachPoint_eq13715931348400830039.png" alt="$\Sigma_{\overline{w}}$">.</p><pre class="codeinput">umax = 0.1;
mean_disturbance = zeros(4,1);
covariance_disturbance = diag([1e-4, 1e-4, 5e-8, 5e-8]);
<span class="comment">% Define the CWH (planar) dynamics of the deputy spacecraft relative to the</span>
<span class="comment">% chief spacecraft as a LtiSystem object</span>
sys = getCwhLtiSystem(4, Polyhedron(<span class="string">'lb'</span>, -umax*ones(2,1), <span class="keyword">...</span>
                                        <span class="string">'ub'</span>,  umax*ones(2,1)), <span class="keyword">...</span>
       RandomVector(<span class="string">'Gaussian'</span>, mean_disturbance,covariance_disturbance));
</pre><h2 id="5">Target tube definition</h2><p>We define the target tube to be a collection of time-varying boxes <img src="cwhSReachPoint_eq00703114625053978951.png" alt="$\{\mathcal{T}_k\}_{k=0}^N$"> where <img src="cwhSReachPoint_eq03672095713503266041.png" alt="$N$"> is the time horizon.</p><p>In this problem, we define <img src="cwhSReachPoint_eq02691184912030422800.png" alt="$\mathcal{T}_k$"> to be line-of-sight cone originating from origin (location of the chief spacecraft) for <img src="cwhSReachPoint_eq05617489819370963802.png" alt="$k\in\{0,1,\ldots,N-1\}$"> and the terminal target set <img src="cwhSReachPoint_eq16701108298818361320.png" alt="$\mathcal{T}_N$"> as a box around the origin. This special sequence of target sets allows us to impose a reach-avoid specification of safety.</p><pre class="codeinput">time_horizon = 5;   <span class="comment">% Stay within a line of sight cone for 4 time steps and</span>
                    <span class="comment">% reach the target at t=5% Safe Set --- LoS cone</span>
<span class="comment">% Safe set definition --- LoS cone |x|&lt;=y and y\in[0,ymax] and |vx|&lt;=vxmax and</span>
<span class="comment">% |vy|&lt;=vymax</span>
ymax = 2;
vxmax = 0.5;
vymax = 0.5;
A_safe_set = [1, 1, 0, 0;
             -1, 1, 0, 0;
              0, -1, 0, 0;
              0, 0, 1,0;
              0, 0,-1,0;
              0, 0, 0,1;
              0, 0, 0,-1];
b_safe_set = [0;
              0;
              ymax;
              vxmax;
              vxmax;
              vymax;
              vymax];
safe_set = Polyhedron(A_safe_set, b_safe_set);
<span class="comment">% Target set --- Box [-0.1,0.1]x[-0.1,0]x[-0.01,0.01]x[-0.01,0.01]</span>
target_set = Polyhedron(<span class="string">'lb'</span>, [-0.1; -0.1; -0.01; -0.01], <span class="keyword">...</span>
                        <span class="string">'ub'</span>, [0.1; 0; 0.01; 0.01]);
target_tube = Tube(<span class="string">'reach-avoid'</span>,safe_set, target_set, time_horizon);
</pre><h2 id="6">Specifying initial states and which options to run</h2><pre class="codeinput">chance_open_run = 1;
genzps_open_run = 1;
particle_open_run = 1;
voronoi_open_run = 1;
chance_affine_run = 1;
voronoi_affine_run = 1;
<span class="comment">% Initial state definition</span>
initial_state = [-0.75;         <span class="comment">% Initial x relative position</span>
                 -0.75;         <span class="comment">% Initial y relative position</span>
                 0;             <span class="comment">% Initial x relative velocity</span>
                 0];            <span class="comment">% Initial y relative velocity</span>
slice_at_vx_vy = initial_state(3:4);
<span class="comment">% Initial states for each of the method</span>
init_state_chance_open = initial_state;
init_state_genzps_open = initial_state;
init_state_particle_open = initial_state;
init_state_voronoi_open = initial_state;
init_state_chance_affine = initial_state;
init_state_voronoi_affine = initial_state;
</pre><h2 id="7">Quantities needed to compute the optimal mean trajectory and Monte-Carlo sims</h2><p>We first compute the dynamics of the concatenated state vector <img src="cwhSReachPoint_eq11848142257603145676.png" alt="$X = Z x_0 + H U + G W$">, and compute the concatentated random vector <img src="cwhSReachPoint_eq14900514129597942148.png" alt="$W$"> and its mean.</p><pre class="codeinput">[Z,H,G] = sys.getConcatMats(time_horizon);
<span class="comment">% Compute the mean trajectory of the concatenated disturbance vector</span>
muW = sys.dist.concat(time_horizon).parameters.mean;
<span class="comment">% Number of Monte-Carloo simulations to use: We will use a lower simulation</span>
<span class="comment">% count for the affine controllers so that its saturation will not take a lot of</span>
<span class="comment">% time</span>
n_mcarlo_sims = 1e5;
n_mcarlo_sims_affine = 1e5;
</pre><h2 id="8"><tt>SReachPoint</tt>: <tt>chance-open</tt></h2><p>This method is discussed in <a href="http://hscl.unm.edu/affinecontrollersynthesis">Vinod and Oishi, Hybrid Systems: Computation and Control, 2019 (submitted)</a>. It was introduced for stochastic reachability in <a href="http://doi.org/10.1109/CDC.2013.6760626">Lesser et. al., Conference on Decision and Control, 2013</a>.</p><p>This approach implements the chance-constrained approach to compute an optimal open-loop controller. It uses risk allocation and piecewise-affine overapproximation of the inverse normal cumulative density function to formulate a linear program for this purpose. Naturally, this is one of the fastest ways to compute an open-loop controller and an underapproximative probabilistic guarantee of safety. However, due to the use of Boole's inequality for risk allocation, it provides a conservative estimate of safety using the open-loop controller.</p><pre class="codeinput"><span class="keyword">if</span> chance_open_run
    fprintf(<span class="string">'\n\nSReachPoint with chance-open\n'</span>);
    <span class="comment">% Set the maximum piecewise-affine overapproximation error to 1e-3</span>
    opts = SReachPointOptions(<span class="string">'term'</span>, <span class="string">'chance-open'</span>,<span class="string">'pwa_accuracy'</span>,1e-3);
    tic;
    [prob_chance_open, opt_input_vec_chance_open] = SReachPoint(<span class="string">'term'</span>, <span class="keyword">...</span>
        <span class="string">'chance-open'</span>, sys, init_state_chance_open, target_tube, opts);
    elapsed_time_chance_open = toc;
    <span class="keyword">if</span> prob_chance_open
        <span class="comment">% Optimal mean trajectory construction</span>
        <span class="comment">% mean_X = Z * x_0 + H * U + G * \mu_W</span>
        opt_mean_X_chance_open = Z * init_state_chance_open + <span class="keyword">...</span>
            H * opt_input_vec_chance_open + G * muW;
        opt_mean_traj_chance_open = reshape(opt_mean_X_chance_open, <span class="keyword">...</span>
            sys.state_dim,[]);
        <span class="comment">% Check via Monte-Carlo simulation</span>
        concat_state_realization_ccc = generateMonteCarloSims(n_mcarlo_sims, <span class="keyword">...</span>
            sys, init_state_chance_open, time_horizon,<span class="keyword">...</span>
            opt_input_vec_chance_open);
        mcarlo_result = target_tube.contains(concat_state_realization_ccc);
        simulated_prob_chance_open = sum(mcarlo_result)/n_mcarlo_sims;
    <span class="keyword">else</span>
        simulated_prob_chance_open = NaN;
    <span class="keyword">end</span>
    fprintf(<span class="string">'SReachPoint underapprox. prob: %1.2f | Simulated prob: %1.2f\n'</span>,<span class="keyword">...</span>
        prob_chance_open, simulated_prob_chance_open);
    fprintf(<span class="string">'Computation time: %1.3f\n'</span>, elapsed_time_chance_open);
<span class="keyword">end</span>
</pre><pre class="codeoutput">

SReachPoint with chance-open
SReachPoint underapprox. prob: 0.87 | Simulated prob: 0.87
Computation time: 0.335
</pre><h2 id="9"><tt>SReachPoint</tt>: <tt>genzps-open</tt></h2><p>This method is discussed in <a href="http://doi.org/10.1109/LCSYS.2017.2716364">Vinod and Oishi, Control System Society- Letters, 2017</a>.</p><p>This approach implements the Fourier transform-based approach to compute an optimal open-loop controller. It uses <a href="http://www.math.wsu.edu/faculty/genz/software/matlab/qsimvnv.m">Genz's algorithm</a> to compute the probability of safety and optimizes the joint chance constraint involved in maximizing this probability. To handle the noisy behaviour of the Genz's algorithm, we rely on MATLAB's <tt>patternsearch</tt> for the nonlinear optimization. Internally, we use the <tt>chance-open</tt> to initialize the nonlinear solver. Hence, this approach will return an open-loop controller with safety at least as good as <tt>chance-open</tt>.</p><pre class="codeinput"><span class="keyword">if</span> genzps_open_run
    fprintf(<span class="string">'\n\nSReachPoint with genzps-open\n'</span>);
    opts = SReachPointOptions(<span class="string">'term'</span>, <span class="string">'genzps-open'</span>, <span class="keyword">...</span>
        <span class="string">'PSoptions'</span>,psoptimset(<span class="string">'display'</span>,<span class="string">'iter'</span>));
    tic
    [prob_genzps_open, opt_input_vec_genzps_open] = SReachPoint(<span class="string">'term'</span>, <span class="keyword">...</span>
        <span class="string">'genzps-open'</span>, sys, init_state_genzps_open, target_tube, opts);
    elapsed_time_genzps = toc;
    <span class="keyword">if</span> prob_genzps_open &gt; 0
        <span class="comment">% Optimal mean trajectory construction</span>
        <span class="comment">% mean_X = Z * x_0 + H * U + G * \mu_W</span>
        opt_mean_X_genzps_open =  Z * init_state_genzps_open + <span class="keyword">...</span>
            H * opt_input_vec_genzps_open + G * muW;
        opt_mean_traj_genzps_open= reshape(opt_mean_X_genzps_open, <span class="keyword">...</span>
            sys.state_dim,[]);
        <span class="comment">% Check via Monte-Carlo simulation</span>
        concat_state_realization_genz = generateMonteCarloSims(n_mcarlo_sims,<span class="keyword">...</span>
            sys, init_state_genzps_open, time_horizon,<span class="keyword">...</span>
            opt_input_vec_genzps_open);
        mcarlo_result = target_tube.contains(concat_state_realization_genz);
        simulated_prob_genzps_open = sum(mcarlo_result)/n_mcarlo_sims;
    <span class="keyword">else</span>
        simulated_prob_genzps_open = NaN;
    <span class="keyword">end</span>
    fprintf(<span class="string">'SReachPoint underapprox. prob: %1.2f | Simulated prob: %1.2f\n'</span>,<span class="keyword">...</span>
        prob_genzps_open, simulated_prob_genzps_open);
    fprintf(<span class="string">'Computation time: %1.3f\n'</span>, elapsed_time_genzps);
<span class="keyword">end</span>
</pre><pre class="codeoutput">

SReachPoint with genzps-open


Iter     Func-count       f(x)      MeshSize     Method
    0           1        0.14387             1      
    1          15        0.14387           0.5     Refine Mesh
    2          29        0.14387          0.25     Refine Mesh
    3          43        0.14387         0.125     Refine Mesh
    4          65        0.14387        0.0625     Refine Mesh
    5          92        0.14387       0.03125     Refine Mesh
    6         119        0.14387       0.01562     Refine Mesh
    7         146        0.14387      0.007812     Refine Mesh
    8         173        0.14387      0.003906     Refine Mesh
    9         200        0.14387      0.001953     Refine Mesh
   10         227        0.14387     0.0009766     Refine Mesh
   11         261        0.14387     0.0004883     Refine Mesh
   12         295        0.14387     0.0002441     Refine Mesh
   13         329        0.14387     0.0001221     Refine Mesh
   14         363        0.14387     6.104e-05     Refine Mesh
   15         397        0.14387     3.052e-05     Refine Mesh
   16         431        0.14387     1.526e-05     Refine Mesh
   17         465        0.14387     7.629e-06     Refine Mesh
   18         499        0.14387     3.815e-06     Refine Mesh
   19         533        0.14387     1.907e-06     Refine Mesh
   20         567        0.14387     9.537e-07     Refine Mesh
Optimization terminated: mesh size less than options.MeshTolerance.
SReachPoint underapprox. prob: 0.87 | Simulated prob: 0.87
Computation time: 7.227
</pre><h2 id="10"><tt>SReachPoint</tt>: <tt>particle-open</tt></h2><p>This method is discussed in <a href="http://doi.org/10.1109/CDC.2013.6760626">Lesser et. al., Conference on Decision and Control, 2013</a>.</p><p>This approach implements the particle control approach to compute an open-loop controller. It is a sampling-based technique and hence the resulting probability estimate is random with its variance going to zero as the number of samples considered goes to infinity. Note that since a mixed-integer linear program is solved underneath with the number of binary variables corresponding to the number of particles, using too many particles can cause an exponential increase in computational time.</p><pre class="codeinput"><span class="keyword">if</span> particle_open_run
    fprintf(<span class="string">'\n\nSReachPoint with particle-open\n'</span>);
    opts = SReachPointOptions(<span class="string">'term'</span>,<span class="string">'particle-open'</span>,<span class="string">'verbose'</span>, 1,<span class="keyword">...</span>
        <span class="string">'n_particles'</span>,50);
    tic
    [prob_particle_open, opt_input_vec_particle_open] = SReachPoint(<span class="string">'term'</span>, <span class="keyword">...</span>
        <span class="string">'particle-open'</span>, sys, init_state_particle_open, target_tube, opts);
    elapsed_time_particle = toc;
    <span class="keyword">if</span> prob_particle_open &gt; 0
        <span class="comment">% Optimal mean trajectory construction</span>
        <span class="comment">% mean_X = Z * x_0 + H * U + G * \mu_W</span>
        opt_mean_X_particle_open =  Z * init_state_particle_open + <span class="keyword">...</span>
            H * opt_input_vec_particle_open + G * muW;
        opt_mean_traj_particle_open =<span class="keyword">...</span>
            reshape(opt_mean_X_particle_open, sys.state_dim,[]);
        <span class="comment">% Check via Monte-Carlo simulation</span>
        concat_state_realization_pa = generateMonteCarloSims(n_mcarlo_sims, <span class="keyword">...</span>
            sys, init_state_particle_open,time_horizon,<span class="keyword">...</span>
            opt_input_vec_particle_open);
        mcarlo_result = target_tube.contains(concat_state_realization_pa);
        simulated_prob_particle_open = sum(mcarlo_result)/n_mcarlo_sims;
    <span class="keyword">else</span>
        simulated_prob_particle_open = NaN;
    <span class="keyword">end</span>
    fprintf(<span class="string">'SReachPoint approx. prob: %1.2f | Simulated prob: %1.2f\n'</span>,<span class="keyword">...</span>
        prob_particle_open, simulated_prob_particle_open);
    fprintf(<span class="string">'Computation time: %1.3f\n'</span>, elapsed_time_particle);
<span class="keyword">end</span>
</pre><pre class="codeoutput">

SReachPoint with particle-open
Creating random variable realizations....Done
Setting up CVX problem....Done
Parsing and solving the MILP....Done
SReachPoint approx. prob: 0.88 | Simulated prob: 0.84
Computation time: 1.237
</pre><h2 id="11"><tt>SReachPoint</tt>: <tt>voronoi-open</tt></h2><p>This method is discussed in <a href="https://arxiv.org/abs/1811.03643">Sartipizadeh, et. al., American Control Conference, 2019 (submitted)</a></p><p>This approach implements the undersampled particle control approach to compute an open-loop controller. It computes, using k-means, a representative sample realization of the disturbance which is significantly smaller. This drastically improves the computational efficiency of the particle control approach. Further, because it uses Hoeffding's inequality, the user can specify an upper-bound on the overapproximation error. The undersampled probability estimate is used to create a lower bound of the solution corresponding to the original particle control problem with appropriate (typically large) number of particles. Thus, this has all the benefits of the <tt>particle-open</tt> option, with additional benefits of being able to specify a maximum overapproximation error as well being computationally tractable.</p><pre class="codeinput"><span class="keyword">if</span> voronoi_open_run
    fprintf(<span class="string">'\n\nSReachPoint with voronoi-open\n'</span>);
    opts = SReachPointOptions(<span class="string">'term'</span>,<span class="string">'voronoi-open'</span>,<span class="string">'verbose'</span>,1,<span class="keyword">...</span>
        <span class="string">'max_overapprox_err'</span>, 1e-3, <span class="string">'undersampling_fraction'</span>, 0.001);
    tic
    [prob_voronoi_open, opt_input_vec_voronoi_open, kmeans_info_open] =<span class="keyword">...</span>
        SReachPoint(<span class="string">'term'</span>, <span class="string">'voronoi-open'</span>, sys, init_state_voronoi_open,<span class="keyword">...</span>
            target_tube, opts);
    elapsed_time_voronoi = toc;
    <span class="keyword">if</span> prob_voronoi_open &gt; 0
        <span class="comment">% Optimal mean trajectory construction</span>
        <span class="comment">% mean_X = Z * x_0 + H * U + G * \mu_W</span>
        opt_mean_X_voronoi_open =  Z * init_state_voronoi_open + <span class="keyword">...</span>
            H * opt_input_vec_voronoi_open + G * muW;
        opt_mean_traj_voronoi_open =<span class="keyword">...</span>
            reshape(opt_mean_X_voronoi_open, sys.state_dim,[]);
        <span class="comment">% Check via Monte-Carlo simulation</span>
        concat_state_realization_vo = generateMonteCarloSims(n_mcarlo_sims, <span class="keyword">...</span>
            sys, init_state_voronoi_open,time_horizon,<span class="keyword">...</span>
            opt_input_vec_voronoi_open);
        mcarlo_result = target_tube.contains(concat_state_realization_vo);
        simulated_prob_voronoi_open = sum(mcarlo_result)/n_mcarlo_sims;
    <span class="keyword">else</span>
        simulated_prob_voronoi_open = NaN;
    <span class="keyword">end</span>
    fprintf(<span class="string">'SReachPoint approx. prob: %1.2f | Simulated prob: %1.2f\n'</span>,<span class="keyword">...</span>
        prob_voronoi_open, simulated_prob_voronoi_open);
    fprintf(<span class="string">'Computation time: %1.3f\n'</span>, elapsed_time_voronoi);
<span class="keyword">end</span>
</pre><pre class="codeoutput">

SReachPoint with voronoi-open
Undersampling fraction is too severe. Using the minimum number of particles prescribed.
Required number of particles: 1.1513e+04 | Samples used:  30
Creating random variable realizations....Done
Using k-means for undersampling....Done
Setting up CVX problem....Done
Parsing and solving the MILP....Done
Undersampled probability (with 30 particles): 0.381
Underapproximation to the original MILP (with 11513 particles): 0.860
SReachPoint approx. prob: 0.86 | Simulated prob: 0.86
Computation time: 1.171
</pre><h2 id="12"><tt>SReachPoint</tt>: <tt>chance-affine</tt></h2><p>This method is discussed in <a href="http://hscl.unm.edu/affinecontrollersynthesis">Vinod and Oishi, Hybrid Systems: Computation and Control, 2019 (submitted)</a>.</p><p>This approach implements the chance-constrained approach to compute a locally optimal affine disturbance feedback controller. In contrast to <tt>chance-open</tt>, this approach optimizes for an affine feedback gain for the concatenated disturbance vector as well as a bias. The resulting optimization problem is non-convex, and <tt>SReachTools</tt> formulates a difference-of-convex program to solve this optimization problem to a local optimum. Since affine disturbance feedback controllers can not satisfy hard control bounds, we relax the control bounds to be probabilistically violated with at most a probability of 0.01. After obtaining the affine feedback controller, we compute a lower bound to the maximal reach probability in the event saturation is applied to satisfy the hard control bounds. Due to its incorporation of state-feedback, this approach typically permits the construction of the highest underapproximative probability guarantee.</p><pre class="codeinput"><span class="keyword">if</span> chance_affine_run
    fprintf(<span class="string">'\n\nSReachPoint with chance-affine\n'</span>);
    opts = SReachPointOptions(<span class="string">'term'</span>, <span class="string">'chance-affine'</span>,<span class="keyword">...</span>
        <span class="string">'max_input_viol_prob'</span>, 1e-2, <span class="string">'verbose'</span>, 2);
    tic
    [prob_chance_affine, opt_input_vec_chance_affine,<span class="keyword">...</span>
        opt_input_gain_chance_affine] = SReachPoint(<span class="string">'term'</span>, <span class="string">'chance-affine'</span>,<span class="keyword">...</span>
            sys, init_state_chance_affine, target_tube, opts);
    elapsed_time_chance_affine = toc;
    fprintf(<span class="string">'Computation time: %1.3f\n'</span>, elapsed_time_chance_affine);
    <span class="keyword">if</span> prob_chance_affine &gt; 0
        <span class="comment">% mean_X = Z * x_0 + H * (M \mu_W + d) + G * \mu_W</span>
        opt_mean_X_chance_affine = Z * init_state_chance_affine +<span class="keyword">...</span>
            H * opt_input_vec_chance_affine + <span class="keyword">...</span>
            (H * opt_input_gain_chance_affine + G) * muW;
        <span class="comment">% Optimal mean trajectory construction</span>
        opt_mean_traj_chance_affine = reshape(opt_mean_X_chance_affine, <span class="keyword">...</span>
            sys.state_dim,[]);
        <span class="comment">% Check via Monte-Carlo simulation</span>
        concat_state_realization_cca = generateMonteCarloSims(<span class="keyword">...</span>
            n_mcarlo_sims_affine, sys, init_state_chance_affine, <span class="keyword">...</span>
            time_horizon, opt_input_vec_chance_affine,<span class="keyword">...</span>
            opt_input_gain_chance_affine, 1);
        mcarlo_result = target_tube.contains(concat_state_realization_cca);
        simulated_prob_chance_affine = sum(mcarlo_result)/n_mcarlo_sims_affine;
    <span class="keyword">else</span>
        simulated_prob_chance_affine = NaN;
    <span class="keyword">end</span>
    fprintf(<span class="string">'SReachPoint underapprox. prob: %1.2f | Simulated prob: %1.2f\n'</span>,<span class="keyword">...</span>
        prob_chance_affine, simulated_prob_chance_affine);
<span class="keyword">end</span>
</pre><pre class="codeoutput">

SReachPoint with chance-affine
Setting up the CVX problem
 0. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.010 | tau_iter: 1
DC slack-total sum --- state: 6.56e+02 | input: 6.12e+02

Setting up the CVX problem
 1. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.787 | tau_iter: 2.000e+00
DC slack-total sum --- state: 2.46e-09 | input: 1.77e-09 | Acceptable: &lt;1.000e-08
DC convergence error: 1.27e+03 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
 2. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.889 | tau_iter: 4.000e+00
DC slack-total sum --- state: 4.05e-10 | input: 2.09e-10 | Acceptable: &lt;1.000e-08
DC convergence error: 1.02e-01 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
 3. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.928 | tau_iter: 8.000e+00
DC slack-total sum --- state: 1.54e-10 | input: 9.47e-11 | Acceptable: &lt;1.000e-08
DC convergence error: 3.91e-02 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
 4. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.952 | tau_iter: 1.600e+01
DC slack-total sum --- state: 2.25e-11 | input: 1.09e-11 | Acceptable: &lt;1.000e-08
DC convergence error: 2.33e-02 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
 5. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.967 | tau_iter: 3.200e+01
DC slack-total sum --- state: 3.73e-13 | input: 1.82e-13 | Acceptable: &lt;1.000e-08
DC convergence error: 1.50e-02 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
 6. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.977 | tau_iter: 6.400e+01
DC slack-total sum --- state: 1.69e-12 | input: 8.16e-13 | Acceptable: &lt;1.000e-08
DC convergence error: 1.01e-02 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
 7. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.984 | tau_iter: 1.280e+02
DC slack-total sum --- state: 4.74e-13 | input: 2.58e-13 | Acceptable: &lt;1.000e-08
DC convergence error: 6.95e-03 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
 8. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.989 | tau_iter: 2.560e+02
DC slack-total sum --- state: 1.97e-13 | input: 1.09e-13 | Acceptable: &lt;1.000e-08
DC convergence error: 4.81e-03 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
 9. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.992 | tau_iter: 5.120e+02
DC slack-total sum --- state: 1.99e-15 | input: 1.10e-15 | Acceptable: &lt;1.000e-08
DC convergence error: 3.33e-03 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
10. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.994 | tau_iter: 1.024e+03
DC slack-total sum --- state: 2.35e-15 | input: 1.31e-15 | Acceptable: &lt;1.000e-08
DC convergence error: 2.33e-03 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
11. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.996 | tau_iter: 2.048e+03
DC slack-total sum --- state: 6.97e-15 | input: 3.87e-15 | Acceptable: &lt;1.000e-08
DC convergence error: 1.63e-03 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
12. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.997 | tau_iter: 4.096e+03
DC slack-total sum --- state: 5.05e-14 | input: 2.81e-14 | Acceptable: &lt;1.000e-08
DC convergence error: 1.14e-03 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
13. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.998 | tau_iter: 8.192e+03
DC slack-total sum --- state: 6.16e-16 | input: 3.42e-16 | Acceptable: &lt;1.000e-08
DC convergence error: 8.09e-04 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
14. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.998 | tau_iter: 1.638e+04
DC slack-total sum --- state: 6.15e-15 | input: 3.42e-15 | Acceptable: &lt;1.000e-08
DC convergence error: 5.74e-04 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
15. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.999 | tau_iter: 3.277e+04
DC slack-total sum --- state: 2.17e-16 | input: 1.21e-16 | Acceptable: &lt;1.000e-08
DC convergence error: 4.07e-04 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
16. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.999 | tau_iter: 6.554e+04
DC slack-total sum --- state: 6.99e-16 | input: 3.88e-16 | Acceptable: &lt;1.000e-08
DC convergence error: 2.94e-04 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
17. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.999 | tau_iter: 1.000e+05
DC slack-total sum --- state: 3.96e-16 | input: 2.20e-16 | Acceptable: &lt;1.000e-08
DC convergence error: 2.14e-04 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
18. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 0.999 | tau_iter: 1.000e+05
DC slack-total sum --- state: 2.32e-16 | input: 1.29e-16 | Acceptable: &lt;1.000e-08
DC convergence error: 1.54e-04 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
19. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 1.000 | tau_iter: 1.000e+05
DC slack-total sum --- state: 3.97e-17 | input: 2.21e-17 | Acceptable: &lt;1.000e-08
DC convergence error: 1.14e-04 | Acceptable: &lt;1.000e-04

Setting up the CVX problem
20. CVX status: Solved | Max iterations : &lt;200
Current probabilty: 1.000 | tau_iter: 1.000e+05
DC slack-total sum --- state: 2.53e-17 | input: 1.41e-17 | Acceptable: &lt;1.000e-08
DC convergence error: 8.48e-05 | Acceptable: &lt;1.000e-04

Computation time: 17.705
Computing the reach probability associated with the given controller via 1.00e+05 Monte-Carlo simulation
Affine disturbance feedback controller will be saturated to the input space via projection
Using Polyhedron/contains to identify realizations that require saturation...Done
We need to saturate 178 realizations. We will provide progress in 5 quantiles.
Completed saturating    36/  178 input realizations
Completed saturating    72/  178 input realizations
Completed saturating   108/  178 input realizations
Completed saturating   144/  178 input realizations
SReachPoint underapprox. prob: 1.00 | Simulated prob: 1.00
</pre><h2 id="13"><tt>SReachPoint</tt>: <tt>voronoi-affine</tt></h2><p>This method extends our previous work in <a href="https://arxiv.org/abs/1811.03643">Sartipizadeh, et. al., American Control Conference, 2019 (submitted)</a> to compute an affine controller. This work will be made available online soon. TODO</p><pre class="codeinput"><span class="keyword">if</span> voronoi_affine_run
    fprintf(<span class="string">'\n\nSReachPoint with voronoi-affine\n'</span>);
    opts = SReachPointOptions(<span class="string">'term'</span>, <span class="string">'voronoi-affine'</span>,<span class="keyword">...</span>
        <span class="string">'max_input_viol_prob'</span>, 1e-2, <span class="string">'verbose'</span>, 1, <span class="string">'min_samples'</span>, 30,<span class="keyword">...</span>
        <span class="string">'max_overapprox_err'</span>, 1e-2);
    tic
    [prob_voronoi_affine, opt_input_vec_voronoi_affine,<span class="keyword">...</span>
        opt_input_gain_voronoi_affine, kmeans_info_affine] = SReachPoint( <span class="keyword">...</span>
            <span class="string">'term'</span>, <span class="string">'voronoi-affine'</span>, sys, init_state_voronoi_affine,<span class="keyword">...</span>
                target_tube, opts);
    elapsed_time_voronoi_affine = toc;
    fprintf(<span class="string">'Computation time: %1.3f\n'</span>, elapsed_time_voronoi_affine);
    <span class="keyword">if</span> prob_voronoi_affine &gt; 0
        <span class="comment">% mean_X = Z * x_0 + H * (M \mu_W + d) + G * \mu_W</span>
        opt_mean_X_voronoi_affine = Z * init_state_voronoi_affine +<span class="keyword">...</span>
            H * opt_input_vec_voronoi_affine + <span class="keyword">...</span>
            (H * opt_input_gain_voronoi_affine + G) * muW;
        <span class="comment">% Optimal mean trajectory construction</span>
        opt_mean_traj_voronoi_affine = reshape(opt_mean_X_voronoi_affine, <span class="keyword">...</span>
            sys.state_dim,[]);
        <span class="comment">% Check via Monte-Carlo simulation</span>
        concat_state_realization_voa = generateMonteCarloSims(<span class="keyword">...</span>
            n_mcarlo_sims_affine, sys, init_state_voronoi_affine,<span class="keyword">...</span>
             time_horizon, opt_input_vec_voronoi_affine,<span class="keyword">...</span>
             opt_input_gain_voronoi_affine, 1);
        mcarlo_result = target_tube.contains(concat_state_realization_voa);
        simulated_prob_voronoi_affine = sum(mcarlo_result)/n_mcarlo_sims_affine;
    <span class="keyword">else</span>
        simulated_prob_voronoi_affine = NaN;
    <span class="keyword">end</span>
    fprintf(<span class="string">'SReachPoint approx. prob: %1.2f | Simulated prob: %1.2f\n'</span>,<span class="keyword">...</span>
        prob_voronoi_affine, simulated_prob_voronoi_affine);
<span class="keyword">end</span>
</pre><pre class="codeoutput">

SReachPoint with voronoi-affine
Undersampling fraction is too severe. Use the minimum number of particles prescribed.
Required number of particles: 1.1520e+03 | Samples used:  30
Creating random variable realizations....Done
Using k-means for undersampling....Done
Setting up CVX problem....
Fraction of buffer constraints enforced (out of 1):1.000
Setup of CVX problem complete
Parsing and solving the MILP....Done
Undersampled probability (with 30 particles): 1.0000
Underapproximation to the original MILP (with 1152 particles): 1.0000
After correction for saturation: 1.0000
Computation time: 24.766
Computing the reach probability associated with the given controller via 1.00e+05 Monte-Carlo simulation
Affine disturbance feedback controller will be saturated to the input space via projection
Using Polyhedron/contains to identify realizations that require saturation...Done
We need to saturate 4830 realizations. We will provide progress in 5 quantiles.
Completed saturating   966/ 4830 input realizations
Completed saturating  1932/ 4830 input realizations
Completed saturating  2898/ 4830 input realizations
Completed saturating  3864/ 4830 input realizations
Completed saturating  4830/ 4830 input realizations
SReachPoint approx. prob: 1.00 | Simulated prob: 0.97
</pre><h2 id="14">Summary of results</h2><p>For ease of comparison, we list the probability estimates, the Monte-Carlo simulation validations, and the computation times once again. We also plot the mean trajectories.</p><pre class="codeinput">dims_to_consider = [1,2];
figure(101);
clf;
hold <span class="string">on</span>;
h_safe_set = plot(safe_set.slice([3,4], slice_at_vx_vy), <span class="string">'color'</span>, <span class="string">'y'</span>);
h_target_set = plot(target_set.slice([3,4], slice_at_vx_vy), <span class="string">'color'</span>, <span class="string">'g'</span>);
h_init_state = scatter(initial_state(1),initial_state(2),200,<span class="string">'k^'</span>);
legend_cell = {<span class="string">'Safe set'</span>,<span class="string">'Target set'</span>,<span class="string">'Initial state'</span>};
axis <span class="string">equal</span>
h_vec = [h_safe_set, h_target_set, h_init_state];
<span class="comment">% Plot the optimal mean trajectory from the vertex under study</span>
<span class="keyword">if</span> chance_open_run &amp;&amp; prob_chance_open &gt; 0
    h_opt_mean_ccc = scatter(<span class="keyword">...</span>
          [init_state_chance_open(1), opt_mean_traj_chance_open(1,:)], <span class="keyword">...</span>
          [init_state_chance_open(2), opt_mean_traj_chance_open(2,:)], <span class="keyword">...</span>
          30, <span class="string">'bo'</span>, <span class="string">'filled'</span>,<span class="string">'DisplayName'</span>, <span class="string">'Mean trajectory (chance-open)'</span>);
    legend_cell{end+1} = <span class="string">'Mean trajectory (chance-open)'</span>;
    h_vec(end+1) = h_opt_mean_ccc;
    ellipsoidsFromMonteCarloSims(<span class="keyword">...</span>
        concat_state_realization_ccc(sys.state_dim+1:end,:), sys.state_dim,<span class="keyword">...</span>
        dims_to_consider, {<span class="string">'b'</span>});
    disp(<span class="string">'&gt;&gt;&gt; SReachPoint with chance-open'</span>)
    fprintf(<span class="string">'SReachPoint underapprox. prob: %1.2f | Simulated prob: %1.2f\n'</span>,<span class="keyword">...</span>
        prob_chance_open, simulated_prob_chance_open);
    fprintf(<span class="string">'Computation time: %1.3f\n'</span>, elapsed_time_chance_open);
<span class="keyword">end</span>
<span class="keyword">if</span> genzps_open_run &amp;&amp; prob_genzps_open &gt; 0
    h_opt_mean_genzps = scatter(<span class="keyword">...</span>
          [init_state_genzps_open(1), opt_mean_traj_genzps_open(1,:)], <span class="keyword">...</span>
          [init_state_genzps_open(2), opt_mean_traj_genzps_open(2,:)], <span class="keyword">...</span>
          50, <span class="string">'kd'</span>,<span class="string">'DisplayName'</span>, <span class="string">'Mean trajectory (genzps-open)'</span>);
    legend_cell{end+1} = <span class="string">'Mean trajectory (genzps-open)'</span>;
    h_vec(end+1) = h_opt_mean_genzps;
    ellipsoidsFromMonteCarloSims(<span class="keyword">...</span>
        concat_state_realization_genz(sys.state_dim+1:end,:), sys.state_dim,<span class="keyword">...</span>
        dims_to_consider, {<span class="string">'k'</span>});
    disp(<span class="string">'&gt;&gt;&gt; SReachPoint with genzps-open'</span>)
    fprintf(<span class="string">'SReachPoint underapprox. prob: %1.2f | Simulated prob: %1.2f\n'</span>,<span class="keyword">...</span>
        prob_genzps_open, simulated_prob_genzps_open);
    fprintf(<span class="string">'Computation time: %1.3f\n'</span>, elapsed_time_genzps);
<span class="keyword">end</span>
<span class="keyword">if</span> particle_open_run &amp;&amp; prob_particle_open &gt; 0
    h_opt_mean_particle = scatter(<span class="keyword">...</span>
          [init_state_particle_open(1), opt_mean_traj_particle_open(1,:)], <span class="keyword">...</span>
          [init_state_particle_open(2), opt_mean_traj_particle_open(2,:)], <span class="keyword">...</span>
          30, <span class="string">'r^'</span>, <span class="string">'filled'</span>,<span class="string">'DisplayName'</span>, <span class="string">'Mean trajectory (particle-open)'</span>);
    legend_cell{end+1} = <span class="string">'Mean trajectory (particle-open)'</span>;
    h_vec(end+1) = h_opt_mean_particle;
    ellipsoidsFromMonteCarloSims(<span class="keyword">...</span>
        concat_state_realization_pa(sys.state_dim+1:end,:), sys.state_dim,<span class="keyword">...</span>
        dims_to_consider, {<span class="string">'r'</span>});
    disp(<span class="string">'&gt;&gt;&gt; SReachPoint with particle-open'</span>)
    fprintf(<span class="string">'SReachPoint approx. prob: %1.2f | Simulated prob: %1.2f\n'</span>,<span class="keyword">...</span>
        prob_particle_open, simulated_prob_particle_open);
    fprintf(<span class="string">'Computation time: %1.3f\n'</span>, elapsed_time_particle);
<span class="keyword">end</span>
<span class="keyword">if</span> voronoi_open_run &amp;&amp; prob_voronoi_open &gt; 0
    h_opt_mean_voronoi = scatter(<span class="keyword">...</span>
          [init_state_voronoi_open(1), opt_mean_traj_voronoi_open(1,:)], <span class="keyword">...</span>
          [init_state_voronoi_open(2), opt_mean_traj_voronoi_open(2,:)], <span class="keyword">...</span>
          30, <span class="string">'cv'</span>, <span class="string">'filled'</span>,<span class="string">'DisplayName'</span>, <span class="string">'Mean trajectory (voronoi-open)'</span>);
    legend_cell{end+1} = <span class="string">'Mean trajectory (voronoi-open)'</span>;
    h_vec(end+1) = h_opt_mean_voronoi;
    ellipsoidsFromMonteCarloSims(<span class="keyword">...</span>
        concat_state_realization_vo(sys.state_dim+1:end,:), sys.state_dim,<span class="keyword">...</span>
        dims_to_consider, {<span class="string">'c'</span>});
    disp(<span class="string">'&gt;&gt;&gt; SReachPoint with voronoi-open'</span>)
    fprintf(<span class="string">'SReachPoint approx. prob: %1.2f | Simulated prob: %1.2f\n'</span>,<span class="keyword">...</span>
        prob_voronoi_open, simulated_prob_voronoi_open);
    fprintf(<span class="string">'Computation time: %1.3f\n'</span>, elapsed_time_voronoi);
<span class="keyword">end</span>
<span class="keyword">if</span> chance_affine_run &amp;&amp; prob_chance_affine &gt; 0
    h_opt_mean_chance_affine = scatter(<span class="keyword">...</span>
          [init_state_chance_affine(1), opt_mean_traj_chance_affine(1,:)], <span class="keyword">...</span>
          [init_state_chance_affine(2), opt_mean_traj_chance_affine(2,:)], <span class="keyword">...</span>
          30, <span class="string">'ms'</span>, <span class="string">'filled'</span>,<span class="string">'DisplayName'</span>, <span class="string">'Mean trajectory (chance-affine)'</span>);
    legend_cell{end+1} = <span class="string">'Mean trajectory (chance-affine)'</span>;
    h_vec(end+1) = h_opt_mean_chance_affine;
    ellipsoidsFromMonteCarloSims(<span class="keyword">...</span>
        concat_state_realization_cca(sys.state_dim+1:end,:), sys.state_dim,<span class="keyword">...</span>
        dims_to_consider, {<span class="string">'m'</span>});
    disp(<span class="string">'&gt;&gt;&gt; SReachPoint with chance-affine'</span>)
    fprintf(<span class="string">'SReachPoint underapprox. prob: %1.2f | Simulated prob: %1.2f\n'</span>,<span class="keyword">...</span>
        prob_chance_affine, simulated_prob_chance_affine);
    fprintf(<span class="string">'Computation time: %1.3f\n'</span>, elapsed_time_chance_affine);
<span class="keyword">end</span>
<span class="keyword">if</span> voronoi_affine_run &amp;&amp; prob_voronoi_affine &gt; 0
    h_opt_mean_voronoi_affine = scatter(<span class="keyword">...</span>
          [init_state_voronoi_affine(1), opt_mean_traj_voronoi_affine(1,:)], <span class="keyword">...</span>
          [init_state_voronoi_affine(2), opt_mean_traj_voronoi_affine(2,:)], <span class="keyword">...</span>
          30, <span class="string">'ks'</span>, <span class="string">'filled'</span>,<span class="string">'DisplayName'</span>, <span class="string">'Mean trajectory (voronoi-affine)'</span>);
    legend_cell{end+1} = <span class="string">'Mean trajectory (voronoi-affine)'</span>;
    h_vec(end+1) = h_opt_mean_voronoi_affine;
    ellipsoidsFromMonteCarloSims(<span class="keyword">...</span>
        concat_state_realization_voa(sys.state_dim+1:end,:), sys.state_dim,<span class="keyword">...</span>
        dims_to_consider, {<span class="string">'k'</span>});
    disp(<span class="string">'&gt;&gt;&gt; SReachPoint with voronoi-affine'</span>)
    fprintf(<span class="string">'SReachPoint approx. prob: %1.2f | Simulated prob: %1.2f\n'</span>,<span class="keyword">...</span>
        prob_voronoi_affine, simulated_prob_voronoi_affine);
    fprintf(<span class="string">'Computation time: %1.3f\n'</span>, elapsed_time_voronoi_affine);
<span class="keyword">end</span>
legend(h_vec, legend_cell, <span class="string">'Location'</span>,<span class="string">'EastOutside'</span>, <span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title([<span class="string">'Ellipsoids fit 100 random Monte-Carlo sims.'</span>]);
axis <span class="string">equal</span>
box <span class="string">on</span>;
grid <span class="string">on</span>;
xlabel(<span class="string">'$x$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
ylabel(<span class="string">'$y$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
set(gca,<span class="string">'FontSize'</span>,20);
axis([initial_state(1)-0.1,-initial_state(1)+0.1,initial_state(2)-0.1,0.1]);
hf = gcf;
hf.Units = <span class="string">'inches'</span>;
hf.Position = [0    0.4167   18.0000   10.0313];
</pre><pre class="codeoutput">&gt;&gt;&gt; SReachPoint with chance-open
SReachPoint underapprox. prob: 0.87 | Simulated prob: 0.87
Computation time: 0.335
&gt;&gt;&gt; SReachPoint with genzps-open
SReachPoint underapprox. prob: 0.87 | Simulated prob: 0.87
Computation time: 7.227
&gt;&gt;&gt; SReachPoint with particle-open
SReachPoint approx. prob: 0.88 | Simulated prob: 0.84
Computation time: 1.237
&gt;&gt;&gt; SReachPoint with voronoi-open
SReachPoint approx. prob: 0.86 | Simulated prob: 0.86
Computation time: 1.171
&gt;&gt;&gt; SReachPoint with chance-affine
SReachPoint underapprox. prob: 1.00 | Simulated prob: 1.00
Computation time: 17.705
&gt;&gt;&gt; SReachPoint with voronoi-affine
SReachPoint approx. prob: 1.00 | Simulated prob: 0.97
Computation time: 24.766
</pre><img vspace="5" hspace="5" src="cwhSReachPoint_01.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Controller synthesis using |SReachPoint| for a spacecraft rendezvous problem
% This example will demonstrate the use of |SReachTools| for controller
% synthesis in a stochastic continuous-state discrete-time linear time-invariant
% (LTI) systems. This example script is part of the |SReachTools| toolbox, which
% is licensed under GPL v3 or (at your option) any later version. A copy of this
% license is given in
% <https://github.com/unm-hscl/SReachTools/blob/master/LICENSE
% https://github.com/unm-hscl/SReachTools/blob/master/LICENSE>.
% 
% In this example script, we discuss how to use |SReachPoint| to synthesize
% open-loop controllers and affine-disturbance feedback controllers for the
% problem of stochastic reachability of a target tube. We demonstrate the
% following solution techniques:
% 
% * |chance-open|: Chance-constrained approach that uses risk allocation and 
%    piecewise-affine approximations to formulate a linear program to
%    synthesize an open-loop controller (See
%    <http://hscl.unm.edu/affinecontrollersynthesis Vinod and Oishi, Hybrid
%    Systems: Computation and Control, 2019 (submitted)>,
%    <http://doi.org/10.1109/CDC.2013.6760626 Lesser et. al., Conference on
%    Decision and Control, 2013>)
% * |genzps-open|: Fourier transforms that uses
%    <http://www.math.wsu.edu/faculty/genz/software/matlab/qsimvnv.m Genz's 
%    algorithm> to formulate a nonlinear log-concave optimization problem to be
%    solved using MATLAB's patternsearch to synthesize an open-loop controller
%    (See <http://doi.org/10.1109/LCSYS.2017.2716364 Vinod and Oishi, Control
%    System Society- Letters, 2017>)
% * |particle-open|: Particle control filter approach that formulates a 
%    mixed-integer linear program to synthesize an open-loop controller (See
%    <http://doi.org/10.1109/CDC.2013.6760626 Lesser et. al., Conference on
%    Decision and Control, 2013>)
% * |voronoi-open|: Particle control filter approach that formulates a
%    mixed-integer linear program to synthesize an open-loop controller. In
%    contrast to |particle-open|, |voronoi-open| permits a user-specified upper
%    bound on the overapproximation error in the maximal reach probability and
%    has significant computational advantages due to its undersampling approach.
%    (See <arxiv_link_TODO Sartipizadeh et. al., American Control Conference,
%    2019 (submitted)>)
% * |chance-affine|: Chance-constrained approach that uses risk allocation and 
%    piecewise-affine approximations to formulate a difference-of-convex program
%    to synthesize a closed-loop (affine disturbance feedback) controller.  The
%    controller synthesis is done by solving a series of second-order cone
%    programs. (See <http://hscl.unm.edu/affinecontrollersynthesis Vinod and
%    Oishi, Hybrid Systems: Computation and Control, 2019 (submitted)>)
%
% All computations were performed using MATLAB on an Intel Xeon CPU with 3.4GHz
% clock rate and 32 GB RAM. The simulation times for individual methods are
% reported in each section along with a Monte-Carlo simulation validation. The
% overall simulation time was 2 minutes. For sake of clarity, all commands were 
% asked to be verbose (via SReachPointOptions). In practice, this can be turned 
% off.
%

% Prescript running: Initializing srtinit, if it already hasn't been initialized
close all;clearvars;srtinit;srtinit REPLACE_WITH_DASH_DASHversion;

%% Problem formulation: Stochastic reachability of a target tube
% Given an initial state $x_0$, a time horizon $N$, a linear system dynamics
% $x_{k+1} = A_k x_k + B_k u_k + F w_k$ for $k\in \{0,1,...,N-1\}$, and a target
% tube ${\{\mathcal{T}_k\}}_{k=0}^N$, we wish to design an admissible controller
% that maximizes the probability of the state staying with the target tube. This
% maximal reach probability, denoted by $V^\ast(x_0)$, is obtained by solving
% the following optimization problem
%
% $$ V^\ast(x_0) = \max_{\overline{U}\in \mathcal{U}^N} P^{x_0,
% \overline{U}}_{X} \{ \forall k, x_k \in \mathcal{T}_k\}.$$
%
% Here, $\overline{U}$ refers to the control policy which satisfies the control
% bounds specified by the input space $\mathcal{U}$ over the entire time
% horizon $N$, $X= {[x_1\ x_2\ \ldots\ x_N]}^\top$ is the concatenated state
% vector, and the target tube is a sequence of sets
% ${\{\mathcal{T}_k\}}_{k=0}^N$.  Here, $X$ is a random vector with probability
% measure $P^{x_0,\overline{U}}_X$ which is a parameterized by the initial state
% $x_0$ and policy $\overline{U}$.  
%
% In the general formulation requires $\overline{U}$ is given by a sequence
% of (potentially time-varying and nonlinear) state-feedback controllers. To
% compute such a policy, we have to resort to dynamic programming which suffers
% from the curse of dimensionality. See these papers for details
% <https://doi.org/10.1016/j.automatica.2008.03.027 Abate et. al, Automatica,
% 2008>, <https://doi.org/10.1016/j.automatica.2010.08.006 Summers and Lygeros,
% Automatica, 2010>, and <https://arxiv.org/abs/1810.05217 Vinod and Oishi,
% IEEE Trans. Automatic Control, 2018 (submitted)>.
%
% |SReachPoint| provides multiple ways to compute an *underapproximation* of
% $V^\ast(x_0)$ by restricting the search to the following controllers:
% 
% * open-loop controller: The controller provides a sequence of control actions
% $\overline{U}={[u_0\ u_1\ \ldots\ u_{N-1}]}^\top\in \mathcal{U}^N$
% parameterized only by the initial state. This controller does not account for
% the actual state realization and therefore can be conservative. However,
% computing this control sequence is easy due to known convexity properties of
% the problem. See <https://arxiv.org/abs/1810.05217 Vinod and Oishi,
% IEEE Trans. Automatic Control, 2018 (submitted)> for more details.  Apart from
% |particle-open|, all approaches provide guaranteed underapproximations or
% underapproximations to a user-specifed error.
% * affine-disturbance feedback controller: The controller is a characterized by
% an affine transformation of the concatenated disturbance vector. The gain
% matrix is forced to be lower-triangular for the causality, resulting in the
% control action at $k$ be dependent only the past disturbance values. 
% Here, the control action at time $k\in \{0,1,\ldots,N-1\}$ is given by $u_k =
% \sum_{i=0}^{k-1} M_{ki} w_i + d_k$.  We optimize for $M_{ki}$ and $d_k$ for
% every $k,i$, and the controller is given by $\overline{U}=MW + d\in
% \mathcal{U}^N$, with $W=[w_0\ w_1\ \ldots\ w_{N-1}]$ denoting the concatenated
% disturbance random vector. By construction, $\overline{U}$ is now random, and
% it can not satisfy hard control bounds with non-zero $M_{ki}$ and unbounded
% $W$. Therefore, we relax the control bound constraints
% $\overline{U}\in\mathcal{U}^N$ to a chance constraint, $P_W\{MW + d\in
% \mathcal{U}^N\}\geq 1-\Delta_U$ permitting the user to specify the
% probabilistic violation $\Delta_U\in[0,1)$ of the control bounds. We then
% construct a lower bound for the maximal reach probability when the affine
% disturbance feedback controller is used under saturation to meet the hard
% control bounds. In contrast to the open-loop controller synthesis, affine
% disturbance feedback controller synthesis is a non-convex problem, and we
% obtain a locally optimal solution using difference-of-convex programming. 
% See <http://hscl.unm.edu/affinecontrollersynthesis
% Vinod and Oishi, Hybrid Systems: Computation and Control, 2019 (submitted)>
% for more details.
%
% All of our approaches are grid-free resulting in highly scalable solutions,
% especially for Gaussian-perturbed linear systems. 
%
% In this example, we perform controller synthesis that maximizes the
% probability of a deputy spacecraft to rendezvous with a chief spacecraft while
% staying within a line-of-sight cone. 
%%
% <<cwh_sketch.png>>
%% Dynamics model for the deputy relative to the chief spacecraft
% We consider both the spacecrafts to be in the same circular orbit. The 
% relative planar dynamics of the deputy with respect to the chief are described 
% by the <https://doi.org/10.1109/CDC.2013.6760626 Clohessy-Wiltshire-Hill (CWH) 
% equations,> 
% 
% $$\ddot{x} - 3 \omega x - 2 \omega \dot{y} = \frac{F_{x}}{m_{d}}$$
% 
% $$            \ddot{y} + 2 \omega \dot{x} = \frac{F_{y}}{m_{d}}$$ 
% 
% where the position of the deputy relative to the chief is $x,y \in
% \mathbf{R}$, $\omega = \sqrt{\frac{\mu}{R_{0}^{3}}}$ is the orbital frequency,
% $\mu$ is the gravitational constant, and $R_{0}$ is the orbital radius of the
% chief spacecraft.  We define the state as $\overline{x} = {[x\ y\ \dot{x}\
% \dot{y}]}^\top \in \mathbf{R}^{4}$ which is the position and velocity of the
% deputy relative to the chief along $\mathrm{x}$- and $\mathrm{y}$- axes, and
% the input as $\overline{u} = {[F_{x}\ F_{y}]}^\top \in
% \mathcal{U}\subset\mathbf{R}^{2}$. 
% 
% We will discretize the CWH dynamics in time, via zero-order hold, to obtain
% the discrete-time linear time-invariant system and add a Gaussian disturbance
% to account for the modeling uncertainties and the disturbance forces,
% 
% $$\overline{x}_{k+1} = A \overline{x}_{k} + B \overline{u}_{k} +
% \overline{w}_{k}$$
% 
% with $\overline{w}_{k} \in \mathbf{R}^{4}$ as an IID Gaussian zero-mean 
% random process with a known covariance matrix $\Sigma_{\overline{w}}$. 

umax = 0.1;
mean_disturbance = zeros(4,1);
covariance_disturbance = diag([1e-4, 1e-4, 5e-8, 5e-8]);
% Define the CWH (planar) dynamics of the deputy spacecraft relative to the
% chief spacecraft as a LtiSystem object
sys = getCwhLtiSystem(4, Polyhedron('lb', -umax*ones(2,1), ...
                                        'ub',  umax*ones(2,1)), ...
       RandomVector('Gaussian', mean_disturbance,covariance_disturbance));


%% Target tube definition
% We define the target tube to be a collection of time-varying boxes
% $\{\mathcal{T}_k\}_{k=0}^N$ where $N$ is the time horizon.
%
% In this problem, we define $\mathcal{T}_k$ to be line-of-sight cone 
% originating from origin (location of the chief spacecraft) for
% $k\in\{0,1,\ldots,N-1\}$ and the terminal target set $\mathcal{T}_N$ as a
% box around the origin. This special sequence of target sets allows us to
% impose a reach-avoid specification of safety.

time_horizon = 5;   % Stay within a line of sight cone for 4 time steps and 
                    % reach the target at t=5% Safe Set REPLACE_WITH_DASH_DASH- LoS cone
% Safe set definition REPLACE_WITH_DASH_DASH- LoS cone |x|<=y and y\in[0,ymax] and |vx|<=vxmax and 
% |vy|<=vymax
ymax = 2;
vxmax = 0.5;
vymax = 0.5;
A_safe_set = [1, 1, 0, 0;           
             -1, 1, 0, 0; 
              0, -1, 0, 0;
              0, 0, 1,0;
              0, 0,-1,0;
              0, 0, 0,1;
              0, 0, 0,-1];
b_safe_set = [0;
              0;
              ymax;
              vxmax;
              vxmax;
              vymax;
              vymax];
safe_set = Polyhedron(A_safe_set, b_safe_set);
% Target set REPLACE_WITH_DASH_DASH- Box [-0.1,0.1]x[-0.1,0]x[-0.01,0.01]x[-0.01,0.01]
target_set = Polyhedron('lb', [-0.1; -0.1; -0.01; -0.01], ...
                        'ub', [0.1; 0; 0.01; 0.01]);
target_tube = Tube('reach-avoid',safe_set, target_set, time_horizon);

%% Specifying initial states and which options to run
chance_open_run = 1;
genzps_open_run = 1;
particle_open_run = 1;
voronoi_open_run = 1;
chance_affine_run = 1;
voronoi_affine_run = 1;
% Initial state definition
initial_state = [-0.75;         % Initial x relative position
                 -0.75;         % Initial y relative position
                 0;             % Initial x relative velocity
                 0];            % Initial y relative velocity
slice_at_vx_vy = initial_state(3:4); 
% Initial states for each of the method
init_state_chance_open = initial_state;
init_state_genzps_open = initial_state;
init_state_particle_open = initial_state;
init_state_voronoi_open = initial_state;
init_state_chance_affine = initial_state;
init_state_voronoi_affine = initial_state;


%% Quantities needed to compute the optimal mean trajectory and Monte-Carlo sims
% We first compute the dynamics of the concatenated state vector $X = Z x_0
% + H U + G W$, and compute the concatentated random vector $W$ and its mean.
[Z,H,G] = sys.getConcatMats(time_horizon);
% Compute the mean trajectory of the concatenated disturbance vector
muW = sys.dist.concat(time_horizon).parameters.mean;
% Number of Monte-Carloo simulations to use: We will use a lower simulation 
% count for the affine controllers so that its saturation will not take a lot of 
% time
n_mcarlo_sims = 1e5;
n_mcarlo_sims_affine = 1e5;     

%% |SReachPoint|: |chance-open|
% This method is discussed in <http://hscl.unm.edu/affinecontrollersynthesis
% Vinod and Oishi, Hybrid Systems: Computation and Control, 2019 (submitted)>.
% It was introduced for stochastic reachability in
% <http://doi.org/10.1109/CDC.2013.6760626 Lesser et. al., Conference on
% Decision and Control, 2013>.
%
% This approach implements the chance-constrained approach to compute an optimal 
% open-loop controller. It uses risk allocation and piecewise-affine
% overapproximation of the inverse normal cumulative density function to
% formulate a linear program for this purpose. Naturally, this is one of the
% fastest ways to compute an open-loop controller and an underapproximative
% probabilistic guarantee of safety. However, due to the use of Boole's
% inequality for risk allocation, it provides a conservative estimate of safety
% using the open-loop controller.
if chance_open_run
    fprintf('\n\nSReachPoint with chance-open\n');
    % Set the maximum piecewise-affine overapproximation error to 1e-3
    opts = SReachPointOptions('term', 'chance-open','pwa_accuracy',1e-3);
    tic;
    [prob_chance_open, opt_input_vec_chance_open] = SReachPoint('term', ...
        'chance-open', sys, init_state_chance_open, target_tube, opts);
    elapsed_time_chance_open = toc;
    if prob_chance_open
        % Optimal mean trajectory construction
        % mean_X = Z * x_0 + H * U + G * \mu_W
        opt_mean_X_chance_open = Z * init_state_chance_open + ...
            H * opt_input_vec_chance_open + G * muW;
        opt_mean_traj_chance_open = reshape(opt_mean_X_chance_open, ...
            sys.state_dim,[]);
        % Check via Monte-Carlo simulation
        concat_state_realization_ccc = generateMonteCarloSims(n_mcarlo_sims, ...
            sys, init_state_chance_open, time_horizon,...
            opt_input_vec_chance_open);
        mcarlo_result = target_tube.contains(concat_state_realization_ccc);
        simulated_prob_chance_open = sum(mcarlo_result)/n_mcarlo_sims;
    else
        simulated_prob_chance_open = NaN;
    end
    fprintf('SReachPoint underapprox. prob: %1.2f | Simulated prob: %1.2f\n',...
        prob_chance_open, simulated_prob_chance_open);
    fprintf('Computation time: %1.3f\n', elapsed_time_chance_open);
end

%% |SReachPoint|: |genzps-open|
% This method is discussed in <http://doi.org/10.1109/LCSYS.2017.2716364
% Vinod and Oishi, Control System Society- Letters, 2017>.
%
% This approach implements the Fourier transform-based approach to compute an
% optimal open-loop controller. It uses
% <http://www.math.wsu.edu/faculty/genz/software/matlab/qsimvnv.m Genz's
% algorithm> to compute the probability of safety and optimizes the joint chance
% constraint involved in maximizing this probability. To handle the noisy
% behaviour of the Genz's algorithm, we rely on MATLAB's |patternsearch| for the
% nonlinear optimization. Internally, we use the
% |chance-open| to initialize the nonlinear solver. Hence, this approach will
% return an open-loop controller with safety at least as good as |chance-open|.
if genzps_open_run
    fprintf('\n\nSReachPoint with genzps-open\n');
    opts = SReachPointOptions('term', 'genzps-open', ...
        'PSoptions',psoptimset('display','iter'));
    tic
    [prob_genzps_open, opt_input_vec_genzps_open] = SReachPoint('term', ...
        'genzps-open', sys, init_state_genzps_open, target_tube, opts);
    elapsed_time_genzps = toc;
    if prob_genzps_open > 0
        % Optimal mean trajectory construction
        % mean_X = Z * x_0 + H * U + G * \mu_W
        opt_mean_X_genzps_open =  Z * init_state_genzps_open + ...
            H * opt_input_vec_genzps_open + G * muW;
        opt_mean_traj_genzps_open= reshape(opt_mean_X_genzps_open, ...
            sys.state_dim,[]);
        % Check via Monte-Carlo simulation
        concat_state_realization_genz = generateMonteCarloSims(n_mcarlo_sims,...
            sys, init_state_genzps_open, time_horizon,...
            opt_input_vec_genzps_open);
        mcarlo_result = target_tube.contains(concat_state_realization_genz);
        simulated_prob_genzps_open = sum(mcarlo_result)/n_mcarlo_sims;
    else
        simulated_prob_genzps_open = NaN;
    end
    fprintf('SReachPoint underapprox. prob: %1.2f | Simulated prob: %1.2f\n',...
        prob_genzps_open, simulated_prob_genzps_open);
    fprintf('Computation time: %1.3f\n', elapsed_time_genzps);    
end

%% |SReachPoint|: |particle-open|
% This method is discussed in <http://doi.org/10.1109/CDC.2013.6760626
% Lesser et. al., Conference on Decision and Control, 2013>.
%
% This approach implements the particle control approach to compute an open-loop
% controller. It is a sampling-based technique and hence the resulting
% probability estimate is random with its variance going to zero as the number
% of samples considered goes to infinity. Note that since a mixed-integer linear
% program is solved underneath with the number of binary variables corresponding
% to the number of particles, using too many particles can cause an exponential
% increase in computational time.
if particle_open_run
    fprintf('\n\nSReachPoint with particle-open\n');
    opts = SReachPointOptions('term','particle-open','verbose', 1,...
        'n_particles',50);
    tic
    [prob_particle_open, opt_input_vec_particle_open] = SReachPoint('term', ...
        'particle-open', sys, init_state_particle_open, target_tube, opts);
    elapsed_time_particle = toc;
    if prob_particle_open > 0
        % Optimal mean trajectory construction
        % mean_X = Z * x_0 + H * U + G * \mu_W
        opt_mean_X_particle_open =  Z * init_state_particle_open + ...
            H * opt_input_vec_particle_open + G * muW;
        opt_mean_traj_particle_open =...
            reshape(opt_mean_X_particle_open, sys.state_dim,[]);
        % Check via Monte-Carlo simulation
        concat_state_realization_pa = generateMonteCarloSims(n_mcarlo_sims, ...
            sys, init_state_particle_open,time_horizon,...
            opt_input_vec_particle_open);
        mcarlo_result = target_tube.contains(concat_state_realization_pa);
        simulated_prob_particle_open = sum(mcarlo_result)/n_mcarlo_sims;
    else
        simulated_prob_particle_open = NaN;
    end
    fprintf('SReachPoint approx. prob: %1.2f | Simulated prob: %1.2f\n',...
        prob_particle_open, simulated_prob_particle_open);
    fprintf('Computation time: %1.3f\n', elapsed_time_particle);
end

%% |SReachPoint|: |voronoi-open|
% This method is discussed in <https://arxiv.org/abs/1811.03643 Sartipizadeh,
% et. al., American Control Conference, 2019 (submitted)>
%
% This approach implements the undersampled particle control approach to compute
% an open-loop controller. It computes, using k-means, a representative sample
% realization of the disturbance which is significantly smaller. This
% drastically improves the computational efficiency of the particle control
% approach. Further, because it uses Hoeffding's inequality, the user can
% specify an upper-bound on the overapproximation error. The undersampled
% probability estimate is used to create a lower bound of the solution
% corresponding to the original particle control problem with appropriate
% (typically large) number of particles. Thus, this has all the benefits of the
% |particle-open| option, with additional benefits of being able to specify a
% maximum overapproximation error as well being computationally tractable.
if voronoi_open_run
    fprintf('\n\nSReachPoint with voronoi-open\n');
    opts = SReachPointOptions('term','voronoi-open','verbose',1,...
        'max_overapprox_err', 1e-3, 'undersampling_fraction', 0.001);
    tic
    [prob_voronoi_open, opt_input_vec_voronoi_open, kmeans_info_open] =...
        SReachPoint('term', 'voronoi-open', sys, init_state_voronoi_open,...
            target_tube, opts);
    elapsed_time_voronoi = toc;
    if prob_voronoi_open > 0
        % Optimal mean trajectory construction
        % mean_X = Z * x_0 + H * U + G * \mu_W
        opt_mean_X_voronoi_open =  Z * init_state_voronoi_open + ...
            H * opt_input_vec_voronoi_open + G * muW;
        opt_mean_traj_voronoi_open =...
            reshape(opt_mean_X_voronoi_open, sys.state_dim,[]);
        % Check via Monte-Carlo simulation
        concat_state_realization_vo = generateMonteCarloSims(n_mcarlo_sims, ...
            sys, init_state_voronoi_open,time_horizon,...
            opt_input_vec_voronoi_open);
        mcarlo_result = target_tube.contains(concat_state_realization_vo);
        simulated_prob_voronoi_open = sum(mcarlo_result)/n_mcarlo_sims;
    else
        simulated_prob_voronoi_open = NaN;
    end
    fprintf('SReachPoint approx. prob: %1.2f | Simulated prob: %1.2f\n',...
        prob_voronoi_open, simulated_prob_voronoi_open);
    fprintf('Computation time: %1.3f\n', elapsed_time_voronoi);
end

%% |SReachPoint|: |chance-affine|
% This method is discussed in <http://hscl.unm.edu/affinecontrollersynthesis
% Vinod and Oishi, Hybrid Systems: Computation and Control, 2019 (submitted)>.
%
% This approach implements the chance-constrained approach to compute a locally
% optimal affine disturbance feedback controller. In contrast to |chance-open|,
% this approach optimizes for an affine feedback gain for the concatenated
% disturbance vector as well as a bias. The resulting optimization problem is
% non-convex, and |SReachTools| formulates a difference-of-convex program to
% solve this optimization problem to a local optimum. Since affine disturbance
% feedback controllers can not satisfy hard control bounds, we relax the control
% bounds to be probabilistically violated with at most a probability of 0.01.
% After obtaining the affine feedback controller, we compute a lower bound to
% the maximal reach probability in the event saturation is applied to satisfy
% the hard control bounds. Due to its incorporation of state-feedback, this
% approach typically permits the construction of the highest underapproximative
% probability guarantee.  
if chance_affine_run
    fprintf('\n\nSReachPoint with chance-affine\n');
    opts = SReachPointOptions('term', 'chance-affine',...
        'max_input_viol_prob', 1e-2, 'verbose', 2);
    tic
    [prob_chance_affine, opt_input_vec_chance_affine,...
        opt_input_gain_chance_affine] = SReachPoint('term', 'chance-affine',...
            sys, init_state_chance_affine, target_tube, opts);
    elapsed_time_chance_affine = toc;
    fprintf('Computation time: %1.3f\n', elapsed_time_chance_affine);
    if prob_chance_affine > 0
        % mean_X = Z * x_0 + H * (M \mu_W + d) + G * \mu_W
        opt_mean_X_chance_affine = Z * init_state_chance_affine +...
            H * opt_input_vec_chance_affine + ...
            (H * opt_input_gain_chance_affine + G) * muW;
        % Optimal mean trajectory construction
        opt_mean_traj_chance_affine = reshape(opt_mean_X_chance_affine, ...
            sys.state_dim,[]);
        % Check via Monte-Carlo simulation
        concat_state_realization_cca = generateMonteCarloSims(...
            n_mcarlo_sims_affine, sys, init_state_chance_affine, ...
            time_horizon, opt_input_vec_chance_affine,...
            opt_input_gain_chance_affine, 1);
        mcarlo_result = target_tube.contains(concat_state_realization_cca);
        simulated_prob_chance_affine = sum(mcarlo_result)/n_mcarlo_sims_affine;
    else
        simulated_prob_chance_affine = NaN;
    end
    fprintf('SReachPoint underapprox. prob: %1.2f | Simulated prob: %1.2f\n',...
        prob_chance_affine, simulated_prob_chance_affine);
end

%% |SReachPoint|: |voronoi-affine|
% This method extends our previous work in <https://arxiv.org/abs/1811.03643 
% Sartipizadeh, et. al., American Control Conference, 2019 (submitted)> to
% compute an affine controller. This work will be made available online
% soon. TODO
%
if voronoi_affine_run
    fprintf('\n\nSReachPoint with voronoi-affine\n');
    opts = SReachPointOptions('term', 'voronoi-affine',...
        'max_input_viol_prob', 1e-2, 'verbose', 1, 'min_samples', 30,...
        'max_overapprox_err', 1e-2);
    tic
    [prob_voronoi_affine, opt_input_vec_voronoi_affine,...
        opt_input_gain_voronoi_affine, kmeans_info_affine] = SReachPoint( ...
            'term', 'voronoi-affine', sys, init_state_voronoi_affine,...
                target_tube, opts);
    elapsed_time_voronoi_affine = toc;
    fprintf('Computation time: %1.3f\n', elapsed_time_voronoi_affine);
    if prob_voronoi_affine > 0
        % mean_X = Z * x_0 + H * (M \mu_W + d) + G * \mu_W
        opt_mean_X_voronoi_affine = Z * init_state_voronoi_affine +...
            H * opt_input_vec_voronoi_affine + ...
            (H * opt_input_gain_voronoi_affine + G) * muW;
        % Optimal mean trajectory construction
        opt_mean_traj_voronoi_affine = reshape(opt_mean_X_voronoi_affine, ...
            sys.state_dim,[]);
        % Check via Monte-Carlo simulation
        concat_state_realization_voa = generateMonteCarloSims(...
            n_mcarlo_sims_affine, sys, init_state_voronoi_affine,...
             time_horizon, opt_input_vec_voronoi_affine,...
             opt_input_gain_voronoi_affine, 1);
        mcarlo_result = target_tube.contains(concat_state_realization_voa);
        simulated_prob_voronoi_affine = sum(mcarlo_result)/n_mcarlo_sims_affine;
    else
        simulated_prob_voronoi_affine = NaN;
    end
    fprintf('SReachPoint approx. prob: %1.2f | Simulated prob: %1.2f\n',...
        prob_voronoi_affine, simulated_prob_voronoi_affine);
end

%% Summary of results
% For ease of comparison, we list the probability estimates, the
% Monte-Carlo simulation validations, and the computation times once again.
% We also plot the mean trajectories.
dims_to_consider = [1,2];
figure(101);
clf;
hold on;
h_safe_set = plot(safe_set.slice([3,4], slice_at_vx_vy), 'color', 'y');
h_target_set = plot(target_set.slice([3,4], slice_at_vx_vy), 'color', 'g');
h_init_state = scatter(initial_state(1),initial_state(2),200,'k^');
legend_cell = {'Safe set','Target set','Initial state'};
axis equal        
h_vec = [h_safe_set, h_target_set, h_init_state];
% Plot the optimal mean trajectory from the vertex under study
if chance_open_run && prob_chance_open > 0
    h_opt_mean_ccc = scatter(...
          [init_state_chance_open(1), opt_mean_traj_chance_open(1,:)], ...
          [init_state_chance_open(2), opt_mean_traj_chance_open(2,:)], ...
          30, 'bo', 'filled','DisplayName', 'Mean trajectory (chance-open)');
    legend_cell{end+1} = 'Mean trajectory (chance-open)';       
    h_vec(end+1) = h_opt_mean_ccc;
    ellipsoidsFromMonteCarloSims(...
        concat_state_realization_ccc(sys.state_dim+1:end,:), sys.state_dim,...
        dims_to_consider, {'b'});
    disp('>>> SReachPoint with chance-open')
    fprintf('SReachPoint underapprox. prob: %1.2f | Simulated prob: %1.2f\n',...
        prob_chance_open, simulated_prob_chance_open);
    fprintf('Computation time: %1.3f\n', elapsed_time_chance_open);    
end
if genzps_open_run && prob_genzps_open > 0
    h_opt_mean_genzps = scatter(...
          [init_state_genzps_open(1), opt_mean_traj_genzps_open(1,:)], ...
          [init_state_genzps_open(2), opt_mean_traj_genzps_open(2,:)], ...
          50, 'kd','DisplayName', 'Mean trajectory (genzps-open)');
    legend_cell{end+1} = 'Mean trajectory (genzps-open)';  
    h_vec(end+1) = h_opt_mean_genzps;
    ellipsoidsFromMonteCarloSims(...
        concat_state_realization_genz(sys.state_dim+1:end,:), sys.state_dim,...
        dims_to_consider, {'k'});
    disp('>>> SReachPoint with genzps-open')
    fprintf('SReachPoint underapprox. prob: %1.2f | Simulated prob: %1.2f\n',...
        prob_genzps_open, simulated_prob_genzps_open);
    fprintf('Computation time: %1.3f\n', elapsed_time_genzps);    
end
if particle_open_run && prob_particle_open > 0
    h_opt_mean_particle = scatter(...
          [init_state_particle_open(1), opt_mean_traj_particle_open(1,:)], ...
          [init_state_particle_open(2), opt_mean_traj_particle_open(2,:)], ...
          30, 'r^', 'filled','DisplayName', 'Mean trajectory (particle-open)');  
    legend_cell{end+1} = 'Mean trajectory (particle-open)';    
    h_vec(end+1) = h_opt_mean_particle;
    ellipsoidsFromMonteCarloSims(...
        concat_state_realization_pa(sys.state_dim+1:end,:), sys.state_dim,...
        dims_to_consider, {'r'});
    disp('>>> SReachPoint with particle-open')
    fprintf('SReachPoint approx. prob: %1.2f | Simulated prob: %1.2f\n',...
        prob_particle_open, simulated_prob_particle_open);
    fprintf('Computation time: %1.3f\n', elapsed_time_particle);    
end
if voronoi_open_run && prob_voronoi_open > 0
    h_opt_mean_voronoi = scatter(...
          [init_state_voronoi_open(1), opt_mean_traj_voronoi_open(1,:)], ...
          [init_state_voronoi_open(2), opt_mean_traj_voronoi_open(2,:)], ...
          30, 'cv', 'filled','DisplayName', 'Mean trajectory (voronoi-open)');  
    legend_cell{end+1} = 'Mean trajectory (voronoi-open)';    
    h_vec(end+1) = h_opt_mean_voronoi;
    ellipsoidsFromMonteCarloSims(...
        concat_state_realization_vo(sys.state_dim+1:end,:), sys.state_dim,...
        dims_to_consider, {'c'});
    disp('>>> SReachPoint with voronoi-open')
    fprintf('SReachPoint approx. prob: %1.2f | Simulated prob: %1.2f\n',...
        prob_voronoi_open, simulated_prob_voronoi_open);
    fprintf('Computation time: %1.3f\n', elapsed_time_voronoi);
end
if chance_affine_run && prob_chance_affine > 0
    h_opt_mean_chance_affine = scatter(...
          [init_state_chance_affine(1), opt_mean_traj_chance_affine(1,:)], ...
          [init_state_chance_affine(2), opt_mean_traj_chance_affine(2,:)], ...
          30, 'ms', 'filled','DisplayName', 'Mean trajectory (chance-affine)');
    legend_cell{end+1} = 'Mean trajectory (chance-affine)';
    h_vec(end+1) = h_opt_mean_chance_affine;
    ellipsoidsFromMonteCarloSims(...
        concat_state_realization_cca(sys.state_dim+1:end,:), sys.state_dim,...
        dims_to_consider, {'m'});
    disp('>>> SReachPoint with chance-affine')
    fprintf('SReachPoint underapprox. prob: %1.2f | Simulated prob: %1.2f\n',...
        prob_chance_affine, simulated_prob_chance_affine);
    fprintf('Computation time: %1.3f\n', elapsed_time_chance_affine);    
end
if voronoi_affine_run && prob_voronoi_affine > 0
    h_opt_mean_voronoi_affine = scatter(...
          [init_state_voronoi_affine(1), opt_mean_traj_voronoi_affine(1,:)], ...
          [init_state_voronoi_affine(2), opt_mean_traj_voronoi_affine(2,:)], ...
          30, 'ks', 'filled','DisplayName', 'Mean trajectory (voronoi-affine)');
    legend_cell{end+1} = 'Mean trajectory (voronoi-affine)';
    h_vec(end+1) = h_opt_mean_voronoi_affine;
    ellipsoidsFromMonteCarloSims(...
        concat_state_realization_voa(sys.state_dim+1:end,:), sys.state_dim,...
        dims_to_consider, {'k'});
    disp('>>> SReachPoint with voronoi-affine')
    fprintf('SReachPoint approx. prob: %1.2f | Simulated prob: %1.2f\n',...
        prob_voronoi_affine, simulated_prob_voronoi_affine);
    fprintf('Computation time: %1.3f\n', elapsed_time_voronoi_affine);    
end
legend(h_vec, legend_cell, 'Location','EastOutside', 'interpreter','latex');
title(['Ellipsoids fit 100 random Monte-Carlo sims.']);
axis equal
box on;
grid on;
xlabel('$x$','interpreter','latex');
ylabel('$y$','interpreter','latex');
set(gca,'FontSize',20);
axis([initial_state(1)-0.1,-initial_state(1)+0.1,initial_state(2)-0.1,0.1]);
hf = gcf;
hf.Units = 'inches';
hf.Position = [0    0.4167   18.0000   10.0313];

##### SOURCE END #####
--></body></html>