
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>cwhSReachPointDemo</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-10-19"><meta name="DC.source" content="cwhSReachPointDemo.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Demonstration of controller synthesis via SReachPoint</a></li><li><a href="#2">Problem formulation: Spacecraft motion via CWH dynamics</a></li><li><a href="#4">Dynamics model for the deputy relative to the chief spacecraft</a></li><li><a href="#5">System definition</a></li><li><a href="#6">Methods to run</a></li><li><a href="#7">Target tube construction --- reach-avoid specification</a></li><li><a href="#9">Initial state definition</a></li><li><a href="#10">Preparation for Monte-Carlo simulations of the optimal controllers</a></li><li><a href="#11">CC (Linear program approach)</a></li><li><a href="#12">CC with affine controllers (Second order cone program approach)</a></li><li><a href="#13">Particle filter approach</a></li><li><a href="#14">Plotting and Monte-Carlo simulation-based validation</a></li><li><a href="#15">Reporting the results</a></li><li><a href="#16">Helper functions</a></li></ul></div><h2 id="1">Demonstration of controller synthesis via SReachPoint</h2><p>This example will demonstrate the use of SReachTools in controller synthesis for stochastic continuous-state discrete-time linear time-invariant (LTI) systems.</p><p>Specifically, we will discuss how SReachTools can use Fourier transforms (<a href="http://www.math.wsu.edu/faculty/genz/software/matlab/qsimvnv.m">Genz's algorithm</a> and MATLAB's patternsearch), particle filter, or convex chance constraints to synthesize open-loop controllers. We also synthesize an affine controller using difference-of-convex program.</p><p>Our approaches is grid-free and recursion-free resulting in highly scalable solutions, especially for Gaussian-perturbed LTI systems.</p><p>This Live Script is part of the SReachTools toolbox. License for the use of this function is given in <a href="https://github.com/unm-hscl/SReachTools/blob/master/LICENSE">https://github.com/unm-hscl/SReachTools/blob/master/LICENSE</a>.</p><pre class="codeinput"><span class="comment">% Prescript running</span>
close <span class="string">all</span>;clc;clear;
srtinit
</pre><h2 id="2">Problem formulation: Spacecraft motion via CWH dynamics</h2><p>We consider both the spacecrafts, referred to as the deputy spacecraft and the chief spacecraft, to be in the same circular orbit. In this example, we will consider the problem of optimal controller synthesis for the deputy such that it can rendezvous with the chief while staying within the line-of-sight cone with maximium likelihood.</p><p><img vspace="5" hspace="5" src="cwh_sketch.png" alt=""> </p><h2 id="4">Dynamics model for the deputy relative to the chief spacecraft</h2><p>The relative planar dynamics of the deputy with respect to the chief are described by the <a href="https://doi.org/10.1109/CDC.2013.6760626">Clohessy-Wiltshire-Hill (CWH) equations,</a></p><p><img src="cwhSReachPointDemo_eq00898161790449768620.png" alt="$$\ddot{x} - 3 \omega x - 2 \omega \dot{y} = \frac{F_{x}}{m_{d}}$$"></p><p><img src="cwhSReachPointDemo_eq15283232495949856112.png" alt="$$            \ddot{y} + 2 \omega \dot{x} = \frac{F_{y}}{m_{d}}$$"></p><p>where the position of the deputy relative to the chief is <img src="cwhSReachPointDemo_eq15556242510480314522.png" alt="$x,y \in \mathbf{R}$">, <img src="cwhSReachPointDemo_eq07285538383886324120.png" alt="$\omega = \sqrt{\frac{\mu}{R_{0}^{3}}}$"> is the orbital frequency, <img src="cwhSReachPointDemo_eq05371638286043275527.png" alt="$\mu$"> is the gravitational constant, and <img src="cwhSReachPointDemo_eq10871390185993502494.png" alt="$R_{0}$"> is the orbital radius of the chief spacecraft.  We define the state as <img src="cwhSReachPointDemo_eq10872751811371042055.png" alt="$\overline{x} = {[x\ y\ \dot{x}\ \dot{y}]}^\top \in \mathbf{R}^{4}$"> which is the position and velocity of the deputy relative to the chief along <img src="cwhSReachPointDemo_eq15238746908345155538.png" alt="$\mathrm{x}$">- and <img src="cwhSReachPointDemo_eq06683332128004049953.png" alt="$\mathrm{y}$">- axes, and the input as <img src="cwhSReachPointDemo_eq03681831066756660658.png" alt="$\overline{u} = {[F_{x}\ F_{y}]}^\top \in \mathcal{U}\subset\mathbf{R}^{2}$">.</p><p>We will discretize the CWH dynamics in time, via zero-order hold, to obtain the discrete-time linear time-invariant system and add a Gaussian disturbance to account for the modeling uncertainties and the disturbance forces,</p><p><img src="cwhSReachPointDemo_eq17824561326300448854.png" alt="$$\overline{x}_{k+1} = A \overline{x}_{k} + B \overline{u}_{k} +&#xA;\overline{w}_{k}$$"></p><p>with <img src="cwhSReachPointDemo_eq17592557756310175309.png" alt="$\overline{w}_{k} \in \mathbf{R}^{4}$"> as an IID Gaussian zero-mean random process with a known covariance matrix <img src="cwhSReachPointDemo_eq13715931348400830039.png" alt="$\Sigma_{\overline{w}}$">.</p><h2 id="5">System definition</h2><pre class="codeinput">umax=0.1;
mean_disturbance = zeros(4,1);
covariance_disturbance = diag([1e-4, 1e-4, 5e-8, 5e-8]);
<span class="comment">% Define the CWH (planar) dynamics of the deputy spacecraft relative to the</span>
<span class="comment">% chief spacecraft as a LtiSystem object</span>
sys = getCwhLtiSystem(4, Polyhedron(<span class="string">'lb'</span>, -umax*ones(2,1),<span class="keyword">...</span>
                                        <span class="string">'ub'</span>,  umax*ones(2,1)),<span class="keyword">...</span>
       RandomVector(<span class="string">'Gaussian'</span>, mean_disturbance,covariance_disturbance));
</pre><h2 id="6">Methods to run</h2><pre class="codeinput">ft_run = 1;
cc_open_run = 1;
cc_affine_run = 1;
pa_open_run = 1;
plot_traj_instead_of_ellipses = 0;
</pre><h2 id="7">Target tube construction --- reach-avoid specification</h2><pre class="codeinput">time_horizon=5;          <span class="comment">% Stay within a line of sight cone for 4 time steps and</span>
                         <span class="comment">% reach the target at t=5% Safe Set --- LoS cone</span>
<span class="comment">% Safe set definition --- LoS cone |x|&lt;=y and y\in[0,ymax] and |vx|&lt;=vxmax and</span>
<span class="comment">% |vy|&lt;=vymax</span>
ymax=2;
vxmax=0.5;
vymax=0.5;
A_safe_set = [1, 1, 0, 0;
             -1, 1, 0, 0;
              0, -1, 0, 0;
              0, 0, 1,0;
              0, 0,-1,0;
              0, 0, 0,1;
              0, 0, 0,-1];
b_safe_set = [0;
              0;
              ymax;
              vxmax;
              vxmax;
              vymax;
              vymax];
safe_set = Polyhedron(A_safe_set, b_safe_set);
<span class="comment">% Target set --- Box [-0.1,0.1]x[-0.1,0]x[-0.01,0.01]x[-0.01,0.01]</span>
target_set = Polyhedron(<span class="string">'lb'</span>, [-0.1; -0.1; -0.01; -0.01],<span class="keyword">...</span>
                        <span class="string">'ub'</span>, [0.1; 0; 0.01; 0.01]);
target_tube = Tube(<span class="string">'reach-avoid'</span>,safe_set, target_set, time_horizon);
</pre><h2 id="9">Initial state definition</h2><pre class="codeinput">initial_state = [-1.15;         <span class="comment">% Initial x relative position</span>
                 -1.15;         <span class="comment">% Initial y relative position</span>
                 0;             <span class="comment">% Initial x relative velocity</span>
                 0];            <span class="comment">% Initial y relative velocity</span>
slice_at_vx_vy = initial_state(3:4);
</pre><h2 id="10">Preparation for Monte-Carlo simulations of the optimal controllers</h2><p>Monte-Carlo simulation parameters</p><pre class="codeinput">n_mcarlo_sims = 1e5;
n_sims_to_plot = 5;      <span class="comment">% Required only if plot_traj_instead_of_ellipses = 1</span>
<span class="comment">% Generate matrices for optimal mean trajectory generation</span>
<span class="comment">% Get H and mean_X_sans_input</span>
[~, H, ~] = getConcatMats(sys, time_horizon);
sysnoi = LtvSystem(<span class="string">'StateMatrix'</span>,sys.state_mat,<span class="string">'DisturbanceMatrix'</span>,<span class="keyword">...</span>
    sys.dist_mat,<span class="string">'Disturbance'</span>,sys.dist);
[mean_X_sans_input, ~] = SReachFwd(<span class="string">'concat-stoch'</span>, sysnoi, initial_state,<span class="keyword">...</span>
    time_horizon);

<span class="keyword">if</span> ft_run
    timer_ft = tic;
    [lb_stoch_reach_avoid_ft, optimal_input_vector_ft] = SReachPoint(<span class="keyword">...</span>
        <span class="string">'term'</span>,<span class="string">'genzps-open'</span>, sys, initial_state, target_tube);
    elapsed_time_ft = toc(timer_ft);
    <span class="keyword">if</span> lb_stoch_reach_avoid_ft &gt; 0
        <span class="comment">% This function returns the concatenated state vector stacked columnwise</span>
        concat_state_realization_ft = generateMonteCarloSims(n_mcarlo_sims,<span class="keyword">...</span>
            sys, initial_state, time_horizon, optimal_input_vector_ft);
        <span class="comment">% Check if the location is within the target_set or not</span>
        mcarlo_result_ft = target_tube.contains(<span class="keyword">...</span>
            [repmat(initial_state,1,n_mcarlo_sims);
             concat_state_realization_ft]);
        <span class="comment">% Optimal mean trajectory generation</span>
        optimal_mean_X_ft = mean_X_sans_input + H * optimal_input_vector_ft;
        optimal_mean_trajectory_ft=reshape(optimal_mean_X_ft,sys.state_dim,[]);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="11">CC (Linear program approach)</h2><p>We will use the default options</p><pre class="codeinput"><span class="keyword">if</span> cc_open_run
    timer_cc_pwl = tic;
    [lb_stoch_reach_avoid_cc_pwl, optimal_input_vector_cc_pwl] = SReachPoint(<span class="keyword">...</span>
        <span class="string">'term'</span>,<span class="string">'chance-open'</span>, sys, initial_state, target_tube);
    elapsed_time_cc_pwl = toc(timer_cc_pwl);
    <span class="keyword">if</span> lb_stoch_reach_avoid_cc_pwl &gt; 0
        <span class="comment">% This function returns the concatenated state vector stacked columnwise</span>
        concat_state_realization_cc_pwl = generateMonteCarloSims(<span class="keyword">...</span>
            n_mcarlo_sims, sys, initial_state, time_horizon,<span class="keyword">...</span>
            optimal_input_vector_cc_pwl);
        <span class="comment">% Check if the location is within the target_set or not</span>
        mcarlo_result_cc_pwl = target_tube.contains(<span class="keyword">...</span>
            [repmat(initial_state,1,n_mcarlo_sims);
             concat_state_realization_cc_pwl]);
        <span class="comment">% Optimal mean trajectory generation</span>
        optimal_mean_X_cc_pwl = mean_X_sans_input +<span class="keyword">...</span>
            H * optimal_input_vector_cc_pwl;
        optimal_mean_trajectory_cc_pwl=reshape(optimal_mean_X_cc_pwl,<span class="keyword">...</span>
            sys.state_dim,[]);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="12">CC with affine controllers (Second order cone program approach)</h2><p>We set <img src="cwhSReachPointDemo_eq00419265617636731199.png" alt="$\Delta_U=0.01$"> and define verbosity level of 1.</p><pre class="codeinput">max_input_viol_prob = 0.01;
<span class="keyword">if</span> cc_affine_run
    timer_cc_affine = tic;
    options = SReachPointOptions(<span class="string">'term'</span>,<span class="string">'chance-affine'</span>,<span class="keyword">...</span>
        <span class="string">'max_input_viol_prob'</span>, 1e-2, <span class="string">'verbose'</span>, 1);
    [lb_stoch_reach_avoid_cc_affine, optimal_input_vector_cc_affine,<span class="keyword">...</span>
        optimal_input_gain, risk_alloc_state, risk_alloc_input] =<span class="keyword">...</span>
         SReachPoint(<span class="string">'term'</span>,<span class="string">'chance-affine'</span>, sys, initial_state, target_tube,<span class="keyword">...</span>
            options);
    elapsed_time_cc_affine = toc(timer_cc_affine);
    <span class="keyword">if</span> lb_stoch_reach_avoid_cc_affine &gt; 0
        <span class="comment">% This function returns the concatenated state vector stacked columnwise</span>
        [concat_state_realization_cc_affine,<span class="keyword">...</span>
            concat_disturb_realization_cc_affine] =<span class="keyword">...</span>
                generateMonteCarloSims(n_mcarlo_sims, sys, initial_state,<span class="keyword">...</span>
                    time_horizon,optimal_input_vector_cc_affine,<span class="keyword">...</span>
                    optimal_input_gain);

        <span class="comment">% Check if the location is within the target_set or not</span>
        mcarlo_result_cc_affine = target_tube.contains(<span class="keyword">...</span>
            [repmat(initial_state,1,n_mcarlo_sims);
             concat_state_realization_cc_affine]);

        <span class="comment">% Check if the input is within the tolerance</span>
        [concat_input_space_A, concat_input_space_b] =<span class="keyword">...</span>
            sys.getConcatInputSpace(time_horizon);
        mcarlo_result_cc_affine_input = any(concat_input_space_A *<span class="keyword">...</span>
            (optimal_input_gain * concat_disturb_realization_cc_affine +<span class="keyword">...</span>
                optimal_input_vector_cc_affine)&lt;=concat_input_space_b);

        <span class="comment">% Optimal mean trajectory generation</span>
        optimal_mean_X_cc_affine = mean_X_sans_input +<span class="keyword">...</span>
            H * optimal_input_vector_cc_affine;
        optimal_mean_trajectory_cc_affine=reshape(<span class="keyword">...</span>
            optimal_mean_X_cc_affine,sys.state_dim,[]);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="13">Particle filter approach</h2><pre class="codeinput"><span class="keyword">if</span> pa_open_run
    timer_pa = tic;
    [lb_stoch_reach_avoid_pa, optimal_input_vector_pa] = SReachPoint(<span class="keyword">...</span>
        <span class="string">'term'</span>,<span class="string">'particle-open'</span>, sys, initial_state, target_tube);
    elapsed_time_pa = toc(timer_pa);
    <span class="keyword">if</span> lb_stoch_reach_avoid_pa &gt; 0
        <span class="comment">% This function returns the concatenated state vector stacked columnwise</span>
        concat_state_realization_pa = generateMonteCarloSims(<span class="keyword">...</span>
            n_mcarlo_sims, sys, initial_state, time_horizon,<span class="keyword">...</span>
            optimal_input_vector_pa);
        <span class="comment">% Check if the location is within the target_set or not</span>
        mcarlo_result_pa = target_tube.contains(<span class="keyword">...</span>
            [repmat(initial_state,1,n_mcarlo_sims);
             concat_state_realization_pa]);
        <span class="comment">% Optimal mean trajectory generation</span>
        optimal_mean_X_pa = mean_X_sans_input +<span class="keyword">...</span>
            H * optimal_input_vector_pa;
        optimal_mean_trajectory_pa=reshape(optimal_mean_X_pa,<span class="keyword">...</span>
            sys.state_dim,[]);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="14">Plotting and Monte-Carlo simulation-based validation</h2><pre class="codeinput">figure(1);
clf
box <span class="string">on</span>;
hold <span class="string">on</span>;
plot(safe_set.slice([3,4], slice_at_vx_vy), <span class="string">'color'</span>, <span class="string">'y'</span>);
plot(target_set.slice([3,4], slice_at_vx_vy), <span class="string">'color'</span>, <span class="string">'g'</span>);
scatter(initial_state(1),initial_state(2),200,<span class="string">'k^'</span>);
legend_cell = {<span class="string">'Safe set'</span>,<span class="string">'Target set'</span>,<span class="string">'Initial state'</span>};
<span class="keyword">if</span> exist(<span class="string">'optimal_mean_trajectory_ft'</span>,<span class="string">'var'</span>)
    scatter([initial_state(1), optimal_mean_trajectory_ft(1,:)],<span class="keyword">...</span>
            [initial_state(2), optimal_mean_trajectory_ft(2,:)],<span class="keyword">...</span>
            30, <span class="string">'ro'</span>, <span class="string">'filled'</span>);
    legend_cell{end+1} = <span class="string">'Optimal mean trajectory (genzps-open)'</span>;
<span class="keyword">end</span>
<span class="keyword">if</span> exist(<span class="string">'optimal_mean_trajectory_cc_pwl'</span>,<span class="string">'var'</span>)
    scatter([initial_state(1), optimal_mean_trajectory_cc_pwl(1,:)],<span class="keyword">...</span>
        [initial_state(2), optimal_mean_trajectory_cc_pwl(2,:)],<span class="keyword">...</span>
        30, <span class="string">'mo'</span>, <span class="string">'filled'</span>);
    legend_cell{end+1} = <span class="string">'Optimal mean trajectory (chance-open)'</span>;
<span class="keyword">end</span>
<span class="keyword">if</span> exist(<span class="string">'optimal_mean_trajectory_pa'</span>,<span class="string">'var'</span>)
    scatter([initial_state(1), optimal_mean_trajectory_pa(1,:)],<span class="keyword">...</span>
        [initial_state(2), optimal_mean_trajectory_pa(2,:)],<span class="keyword">...</span>
        30, <span class="string">'ko'</span>, <span class="string">'filled'</span>);
    legend_cell{end+1} = <span class="string">'Optimal mean trajectory (particle-open)'</span>;
<span class="keyword">end</span>
<span class="keyword">if</span> exist(<span class="string">'optimal_mean_trajectory_cc_affine'</span>,<span class="string">'var'</span>)
    scatter([initial_state(1), optimal_mean_trajectory_cc_affine(1,:)],<span class="keyword">...</span>
        [initial_state(2), optimal_mean_trajectory_cc_affine(2,:)],<span class="keyword">...</span>
        30, <span class="string">'bo'</span>, <span class="string">'filled'</span>);
    legend_cell{end+1} = <span class="string">'Optimal mean trajectory (chance-affine)'</span>;
<span class="keyword">end</span>
legend(legend_cell, <span class="string">'Location'</span>,<span class="string">'South'</span>);
xlabel(<span class="string">'$x$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
ylabel(<span class="string">'$y$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);

figure(2);
clf
box <span class="string">on</span>;
hold <span class="string">on</span>;
plot(safe_set.slice([3,4], slice_at_vx_vy), <span class="string">'color'</span>, <span class="string">'y'</span>);
plot(target_set.slice([3,4], slice_at_vx_vy), <span class="string">'color'</span>, <span class="string">'g'</span>);
scatter(initial_state(1),initial_state(2),200,<span class="string">'k^'</span>);
legend_cell = {<span class="string">'Safe set'</span>,<span class="string">'Target set'</span>,<span class="string">'Initial state'</span>};
<span class="keyword">if</span> exist(<span class="string">'optimal_mean_trajectory_ft'</span>,<span class="string">'var'</span>)
    scatter([initial_state(1), optimal_mean_trajectory_ft(1,:)],<span class="keyword">...</span>
            [initial_state(2), optimal_mean_trajectory_ft(2,:)],<span class="keyword">...</span>
            30, <span class="string">'ro'</span>, <span class="string">'filled'</span>);
    legend_cell{end+1} = <span class="string">'Optimal mean trajectory (genzps-open)'</span>;
    <span class="keyword">if</span> ~isnan(concat_state_realization_ft)
        <span class="keyword">if</span> plot_traj_instead_of_ellipses == 1
            [legend_cell] = plotMonteCarlo(<span class="string">'(genzps-open)'</span>, mcarlo_result_ft,<span class="keyword">...</span>
                concat_state_realization_ft, n_mcarlo_sims, n_sims_to_plot,<span class="keyword">...</span>
                sys.state_dim, initial_state, legend_cell);
        <span class="keyword">else</span>
            ellipsoidsFromMonteCarloSims(concat_state_realization_ft,<span class="keyword">...</span>
                sys.state_dim, [1,2], {<span class="string">'r'</span>});
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">else</span>
    lb_stoch_reach_avoid_ft = NaN;
    mcarlo_result_ft = NaN;
    elapsed_time_ft = NaN;
<span class="keyword">end</span>
<span class="keyword">if</span> exist(<span class="string">'optimal_mean_trajectory_cc_pwl'</span>,<span class="string">'var'</span>)
    scatter([initial_state(1), optimal_mean_trajectory_cc_pwl(1,:)],<span class="keyword">...</span>
        [initial_state(2), optimal_mean_trajectory_cc_pwl(2,:)],<span class="keyword">...</span>
        30, <span class="string">'mo'</span>, <span class="string">'filled'</span>);
    legend_cell{end+1} = <span class="string">'Optimal mean trajectory (chance-open)'</span>;
    <span class="keyword">if</span> ~isnan(concat_state_realization_cc_pwl)
        <span class="keyword">if</span> plot_traj_instead_of_ellipses == 1
            [legend_cell] = plotMonteCarlo(<span class="string">'(chance-open)'</span>, <span class="keyword">...</span>
                mcarlo_result_cc_pwl, concat_state_realization_cc_pwl,<span class="keyword">...</span>
                n_mcarlo_sims, n_sims_to_plot, sys.state_dim, initial_state,<span class="keyword">...</span>
                legend_cell);
        <span class="keyword">else</span>
            ellipsoidsFromMonteCarloSims(concat_state_realization_cc_pwl,<span class="keyword">...</span>
                sys.state_dim, [1,2], {<span class="string">'m'</span>});
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">else</span>
    lb_stoch_reach_avoid_cc_pwl = NaN;
    mcarlo_result_cc_pwl = NaN;
    elapsed_time_cc_pwl = NaN;
<span class="keyword">end</span>
<span class="keyword">if</span> exist(<span class="string">'optimal_mean_trajectory_pa'</span>,<span class="string">'var'</span>)
    scatter([initial_state(1), optimal_mean_trajectory_pa(1,:)],<span class="keyword">...</span>
        [initial_state(2), optimal_mean_trajectory_pa(2,:)],<span class="keyword">...</span>
        30, <span class="string">'ko'</span>, <span class="string">'filled'</span>);
    legend_cell{end+1} = <span class="string">'Optimal mean trajectory (particle-open)'</span>;
    <span class="keyword">if</span> ~isnan(concat_state_realization_pa)
        <span class="keyword">if</span> plot_traj_instead_of_ellipses == 1
            [legend_cell] = plotMonteCarlo(<span class="string">'(particle-open)'</span>, <span class="keyword">...</span>
                mcarlo_result_pa, concat_state_realization_pa,<span class="keyword">...</span>
                n_mcarlo_sims, n_sims_to_plot, sys.state_dim, initial_state,<span class="keyword">...</span>
                legend_cell);
        <span class="keyword">else</span>
            ellipsoidsFromMonteCarloSims(concat_state_realization_pa,<span class="keyword">...</span>
                sys.state_dim, [1,2], {<span class="string">'k'</span>});
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">else</span>
    lb_stoch_reach_avoid_pa = NaN;
    mcarlo_result_pa = NaN;
    elapsed_time_pa = NaN;
<span class="keyword">end</span>

<span class="keyword">if</span> exist(<span class="string">'optimal_mean_trajectory_cc_affine'</span>,<span class="string">'var'</span>)
        scatter([initial_state(1), optimal_mean_trajectory_cc_affine(1,:)],<span class="keyword">...</span>
        [initial_state(2), optimal_mean_trajectory_cc_affine(2,:)],<span class="keyword">...</span>
        30, <span class="string">'bd'</span>, <span class="string">'filled'</span>);
    legend_cell{end+1} = <span class="string">'Optimal mean trajectory (chance-affine)'</span>;
    <span class="keyword">if</span> ~isnan(concat_state_realization_cc_affine)
        <span class="keyword">if</span> plot_traj_instead_of_ellipses==1
            [legend_cell] = plotMonteCarlo(<span class="string">'(chance-affine)'</span>,<span class="keyword">...</span>
                mcarlo_result_cc_affine,<span class="keyword">...</span>
                concat_state_realization_cc_affine, n_mcarlo_sims,<span class="keyword">...</span>
                n_sims_to_plot, sys.state_dim, initial_state, legend_cell);
        <span class="keyword">else</span>
            ellipsoidsFromMonteCarloSims(concat_state_realization_cc_affine,<span class="keyword">...</span>
                sys.state_dim, [1,2], {<span class="string">'b'</span>});
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">else</span>
    lb_stoch_reach_avoid_cc_affine = NaN;
    mcarlo_result_cc_affine = NaN;
    elapsed_time_cc_affine = NaN;
<span class="keyword">end</span>
legend(legend_cell, <span class="string">'Location'</span>,<span class="string">'South'</span>);
<span class="keyword">if</span> plot_traj_instead_of_ellipses==1
    title(sprintf(<span class="string">'Plot with %d Monte-Carlo sims'</span>, n_sims_to_plot));
<span class="keyword">else</span>
    title(<span class="string">'Plot with ellipsoid fit for 100 randomly chosen Monte-Carlo sims'</span>);
<span class="keyword">end</span>
box <span class="string">on</span>;
grid <span class="string">on</span>;
xlabel(<span class="string">'$x$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
ylabel(<span class="string">'$y$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
</pre><img vspace="5" hspace="5" src="cwhSReachPointDemo_01.png" alt=""> <img vspace="5" hspace="5" src="cwhSReachPointDemo_02.png" alt=""> <h2 id="15">Reporting the results</h2><pre class="codeinput"><span class="keyword">if</span> any(isnan([lb_stoch_reach_avoid_cc_pwl, lb_stoch_reach_avoid_ft,<span class="keyword">...</span>
        lb_stoch_reach_avoid_cc_affine, lb_stoch_reach_avoid_pa]))
    disp(<span class="string">'Skipped items would show up as NaN'</span>);
<span class="keyword">end</span>
fprintf([<span class="string">'FT: %1.3f | CC (Open): %1.3f | Scenario (Open): %1.3f | '</span>,<span class="keyword">...</span>
    <span class="string">'CC (Affine): %1.3f\n'</span>],<span class="keyword">...</span>
    lb_stoch_reach_avoid_ft,<span class="keyword">...</span>
    lb_stoch_reach_avoid_cc_pwl,<span class="keyword">...</span>
    lb_stoch_reach_avoid_pa,<span class="keyword">...</span>
    lb_stoch_reach_avoid_cc_affine);
fprintf(<span class="string">'MC (%1.0e particles): %1.3f, %1.3f, %1.3f, %1.3f\n'</span>,<span class="keyword">...</span>
    n_mcarlo_sims,<span class="keyword">...</span>
    sum(mcarlo_result_ft)/n_mcarlo_sims, <span class="keyword">...</span>
    sum(mcarlo_result_cc_pwl)/n_mcarlo_sims,<span class="keyword">...</span>
    sum(mcarlo_result_pa)/n_mcarlo_sims,<span class="keyword">...</span>
    sum(mcarlo_result_cc_affine)/n_mcarlo_sims);
fprintf(<span class="string">'Elapsed time: %1.3f, %1.3f, %1.3f, %1.3f seconds\n'</span>,<span class="keyword">...</span>
    elapsed_time_ft, elapsed_time_cc_pwl, elapsed_time_pa,<span class="keyword">...</span>
    elapsed_time_cc_affine);
</pre><pre class="codeoutput">FT: 0.728 | CC (Open): 0.670 | Scenario (Open): 0.770 | CC (Affine): 0.813
MC (1e+05 particles): 0.728, 0.707, 0.643, 0.831
Elapsed time: 56.978, 0.278, 6.265, 71.380 seconds
</pre><h2 id="16">Helper functions</h2><p>Plotting function</p><pre class="codeinput"><span class="keyword">function</span> [legend_cell] = plotMonteCarlo(method_str, mcarlo_result,<span class="keyword">...</span>
    concat_state_realization, n_mcarlo_sims, n_sims_to_plot, state_dim,<span class="keyword">...</span>
    initial_state, legend_cell)
<span class="comment">% Plots a selection of Monte-Carlo simulations on top of the plot</span>

    green_legend_updated = 0;
    red_legend_updated = 0;
    traj_indices = floor(n_mcarlo_sims*rand(1,n_sims_to_plot));
    <span class="keyword">for</span> realization_index = traj_indices
        <span class="comment">% Check if the trajectory satisfies the reach-avoid objective</span>
        <span class="keyword">if</span> mcarlo_result(realization_index)
            <span class="comment">% Assign green triangle as the marker</span>
            markerString = <span class="string">'g^-'</span>;
        <span class="keyword">else</span>
            <span class="comment">% Assign red asterisk as the marker</span>
            markerString = <span class="string">'r*-'</span>;
        <span class="keyword">end</span>
        <span class="comment">% Create [x(t_1) x(t_2)... x(t_N)]</span>
        reshaped_X_vector = reshape(<span class="keyword">...</span>
            concat_state_realization(:,realization_index), state_dim,[]);
        <span class="comment">% This realization is to be plotted</span>
        h = plot([initial_state(1), reshaped_X_vector(1,:)], <span class="keyword">...</span>
                 [initial_state(2), reshaped_X_vector(2,:)], <span class="keyword">...</span>
                 markerString, <span class="string">'MarkerSize'</span>,10);
        <span class="comment">% Update the legends if the first else, disable</span>
        <span class="keyword">if</span> strcmp(markerString,<span class="string">'g^-'</span>)
            <span class="keyword">if</span> green_legend_updated
                h.Annotation.LegendInformation.IconDisplayStyle = <span class="string">'off'</span>;
            <span class="keyword">else</span>
                green_legend_updated = 1;
                legend_cell{end+1} = strcat(<span class="string">'Good trajectory '</span>, method_str);
            <span class="keyword">end</span>
        <span class="keyword">elseif</span> strcmp(markerString,<span class="string">'r*-'</span>)
            <span class="keyword">if</span> red_legend_updated
                h.Annotation.LegendInformation.IconDisplayStyle = <span class="string">'off'</span>;
            <span class="keyword">else</span>
                red_legend_updated = 1;
                legend_cell{end+1} = strcat(<span class="string">'Bad trajectory '</span>, method_str);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Demonstration of controller synthesis via SReachPoint
% This example will demonstrate the use of SReachTools in controller synthesis
% for stochastic continuous-state discrete-time linear time-invariant (LTI) 
% systems.
% 
% Specifically, we will discuss how SReachTools can use Fourier transforms
% (<http://www.math.wsu.edu/faculty/genz/software/matlab/qsimvnv.m 
% Genz's algorithm> and MATLAB's patternsearch), particle filter, or convex 
% chance constraints to synthesize open-loop controllers. We also synthesize an 
% affine controller using difference-of-convex program.
%
% Our approaches is grid-free and recursion-free resulting in highly scalable
% solutions, especially for Gaussian-perturbed LTI systems. 
%
% This Live Script is part of the SReachTools toolbox. License for the use 
% of this function is given in 
% <https://github.com/unm-hscl/SReachTools/blob/master/LICENSE 
% https://github.com/unm-hscl/SReachTools/blob/master/LICENSE>.

% Prescript running
close all;clc;clear;
srtinit
%% Problem formulation: Spacecraft motion via CWH dynamics
% We consider both the spacecrafts, referred to as the deputy spacecraft and 
% the chief spacecraft, to be in the same circular orbit. In this example, we 
% will consider the problem of optimal controller synthesis for the deputy such 
% that it can rendezvous with the chief while staying within the line-of-sight
% cone with maximium likelihood.
%%
% <<cwh_sketch.png>>
%% Dynamics model for the deputy relative to the chief spacecraft
% The relative planar dynamics of the deputy with respect to the chief are described 
% by the <https://doi.org/10.1109/CDC.2013.6760626 Clohessy-Wiltshire-Hill (CWH) 
% equations,> 
% 
% $$\ddot{x} - 3 \omega x - 2 \omega \dot{y} = \frac{F_{x}}{m_{d}}$$
% 
% $$            \ddot{y} + 2 \omega \dot{x} = \frac{F_{y}}{m_{d}}$$ 
% 
% where the position of the deputy relative to the chief is $x,y \in
% \mathbf{R}$, $\omega = \sqrt{\frac{\mu}{R_{0}^{3}}}$ is the orbital frequency,
% $\mu$ is the gravitational constant, and $R_{0}$ is the orbital radius of the
% chief spacecraft.  We define the state as $\overline{x} = {[x\ y\ \dot{x}\
% \dot{y}]}^\top \in \mathbf{R}^{4}$ which is the position and velocity of the
% deputy relative to the chief along $\mathrm{x}$- and $\mathrm{y}$- axes, and
% the input as $\overline{u} = {[F_{x}\ F_{y}]}^\top \in
% \mathcal{U}\subset\mathbf{R}^{2}$. 
% 
% We will discretize the CWH dynamics in time, via zero-order hold, to obtain
% the discrete-time linear time-invariant system and add a Gaussian disturbance
% to account for the modeling uncertainties and the disturbance forces,
% 
% $$\overline{x}_{k+1} = A \overline{x}_{k} + B \overline{u}_{k} +
% \overline{w}_{k}$$
% 
% with $\overline{w}_{k} \in \mathbf{R}^{4}$ as an IID Gaussian zero-mean 
% random process with a known covariance matrix $\Sigma_{\overline{w}}$. 
 
%% System definition
umax=0.1;
mean_disturbance = zeros(4,1);
covariance_disturbance = diag([1e-4, 1e-4, 5e-8, 5e-8]);
% Define the CWH (planar) dynamics of the deputy spacecraft relative to the
% chief spacecraft as a LtiSystem object
sys = getCwhLtiSystem(4, Polyhedron('lb', -umax*ones(2,1),...
                                        'ub',  umax*ones(2,1)),...
       RandomVector('Gaussian', mean_disturbance,covariance_disturbance));

%% Methods to run   
ft_run = 1;
cc_open_run = 1;
cc_affine_run = 1;
pa_open_run = 1;
plot_traj_instead_of_ellipses = 0;

%% Target tube construction REPLACE_WITH_DASH_DASH- reach-avoid specification
time_horizon=5;          % Stay within a line of sight cone for 4 time steps and 
                         % reach the target at t=5% Safe Set REPLACE_WITH_DASH_DASH- LoS cone
% Safe set definition REPLACE_WITH_DASH_DASH- LoS cone |x|<=y and y\in[0,ymax] and |vx|<=vxmax and 
% |vy|<=vymax
ymax=2;
vxmax=0.5;
vymax=0.5;
A_safe_set = [1, 1, 0, 0;           
             -1, 1, 0, 0; 
              0, -1, 0, 0;
              0, 0, 1,0;
              0, 0,-1,0;
              0, 0, 0,1;
              0, 0, 0,-1];
b_safe_set = [0;
              0;
              ymax;
              vxmax;
              vxmax;
              vymax;
              vymax];
safe_set = Polyhedron(A_safe_set, b_safe_set);
% Target set REPLACE_WITH_DASH_DASH- Box [-0.1,0.1]x[-0.1,0]x[-0.01,0.01]x[-0.01,0.01]
target_set = Polyhedron('lb', [-0.1; -0.1; -0.01; -0.01],...
                        'ub', [0.1; 0; 0.01; 0.01]);
target_tube = Tube('reach-avoid',safe_set, target_set, time_horizon);                    
%%

%% Initial state definition
initial_state = [-1.15;         % Initial x relative position
                 -1.15;         % Initial y relative position
                 0;             % Initial x relative velocity
                 0];            % Initial y relative velocity
slice_at_vx_vy = initial_state(3:4);             

%% Preparation for Monte-Carlo simulations of the optimal controllers
% Monte-Carlo simulation parameters
n_mcarlo_sims = 1e5;
n_sims_to_plot = 5;      % Required only if plot_traj_instead_of_ellipses = 1
% Generate matrices for optimal mean trajectory generation
% Get H and mean_X_sans_input
[~, H, ~] = getConcatMats(sys, time_horizon);
sysnoi = LtvSystem('StateMatrix',sys.state_mat,'DisturbanceMatrix',...
    sys.dist_mat,'Disturbance',sys.dist);
[mean_X_sans_input, ~] = SReachFwd('concat-stoch', sysnoi, initial_state,...
    time_horizon);

if ft_run
    timer_ft = tic;
    [lb_stoch_reach_avoid_ft, optimal_input_vector_ft] = SReachPoint(...
        'term','genzps-open', sys, initial_state, target_tube);  
    elapsed_time_ft = toc(timer_ft);
    if lb_stoch_reach_avoid_ft > 0
        % This function returns the concatenated state vector stacked columnwise
        concat_state_realization_ft = generateMonteCarloSims(n_mcarlo_sims,...
            sys, initial_state, time_horizon, optimal_input_vector_ft);
        % Check if the location is within the target_set or not
        mcarlo_result_ft = target_tube.contains(...
            [repmat(initial_state,1,n_mcarlo_sims);
             concat_state_realization_ft]);
        % Optimal mean trajectory generation                         
        optimal_mean_X_ft = mean_X_sans_input + H * optimal_input_vector_ft;
        optimal_mean_trajectory_ft=reshape(optimal_mean_X_ft,sys.state_dim,[]);                                              
    end
end

%% CC (Linear program approach)
% We will use the default options   
if cc_open_run
    timer_cc_pwl = tic;
    [lb_stoch_reach_avoid_cc_pwl, optimal_input_vector_cc_pwl] = SReachPoint(...
        'term','chance-open', sys, initial_state, target_tube);  
    elapsed_time_cc_pwl = toc(timer_cc_pwl);
    if lb_stoch_reach_avoid_cc_pwl > 0
        % This function returns the concatenated state vector stacked columnwise
        concat_state_realization_cc_pwl = generateMonteCarloSims(...
            n_mcarlo_sims, sys, initial_state, time_horizon,...
            optimal_input_vector_cc_pwl);
        % Check if the location is within the target_set or not
        mcarlo_result_cc_pwl = target_tube.contains(...
            [repmat(initial_state,1,n_mcarlo_sims);
             concat_state_realization_cc_pwl]);
        % Optimal mean trajectory generation                         
        optimal_mean_X_cc_pwl = mean_X_sans_input +...
            H * optimal_input_vector_cc_pwl;
        optimal_mean_trajectory_cc_pwl=reshape(optimal_mean_X_cc_pwl,...
            sys.state_dim,[]);
    end
end

%% CC with affine controllers (Second order cone program approach)     
% We set $\Delta_U=0.01$ and define verbosity level of 1.
max_input_viol_prob = 0.01;
if cc_affine_run
    timer_cc_affine = tic;
    options = SReachPointOptions('term','chance-affine',...
        'max_input_viol_prob', 1e-2, 'verbose', 1);
    [lb_stoch_reach_avoid_cc_affine, optimal_input_vector_cc_affine,...
        optimal_input_gain, risk_alloc_state, risk_alloc_input] =...
         SReachPoint('term','chance-affine', sys, initial_state, target_tube,...
            options);  
    elapsed_time_cc_affine = toc(timer_cc_affine);            
    if lb_stoch_reach_avoid_cc_affine > 0
        % This function returns the concatenated state vector stacked columnwise
        [concat_state_realization_cc_affine,...
            concat_disturb_realization_cc_affine] =...
                generateMonteCarloSims(n_mcarlo_sims, sys, initial_state,...
                    time_horizon,optimal_input_vector_cc_affine,...
                    optimal_input_gain);

        % Check if the location is within the target_set or not
        mcarlo_result_cc_affine = target_tube.contains(...
            [repmat(initial_state,1,n_mcarlo_sims);
             concat_state_realization_cc_affine]);
        
        % Check if the input is within the tolerance
        [concat_input_space_A, concat_input_space_b] =...
            sys.getConcatInputSpace(time_horizon);
        mcarlo_result_cc_affine_input = any(concat_input_space_A *...
            (optimal_input_gain * concat_disturb_realization_cc_affine +...
                optimal_input_vector_cc_affine)<=concat_input_space_b);
        
        % Optimal mean trajectory generation                         
        optimal_mean_X_cc_affine = mean_X_sans_input +...
            H * optimal_input_vector_cc_affine;
        optimal_mean_trajectory_cc_affine=reshape(...
            optimal_mean_X_cc_affine,sys.state_dim,[]);
    end
end

%% Particle filter approach
if pa_open_run
    timer_pa = tic;
    [lb_stoch_reach_avoid_pa, optimal_input_vector_pa] = SReachPoint(...
        'term','particle-open', sys, initial_state, target_tube);  
    elapsed_time_pa = toc(timer_pa);
    if lb_stoch_reach_avoid_pa > 0
        % This function returns the concatenated state vector stacked columnwise
        concat_state_realization_pa = generateMonteCarloSims(...
            n_mcarlo_sims, sys, initial_state, time_horizon,...
            optimal_input_vector_pa);
        % Check if the location is within the target_set or not
        mcarlo_result_pa = target_tube.contains(...
            [repmat(initial_state,1,n_mcarlo_sims);
             concat_state_realization_pa]);
        % Optimal mean trajectory generation                         
        optimal_mean_X_pa = mean_X_sans_input +...
            H * optimal_input_vector_pa;
        optimal_mean_trajectory_pa=reshape(optimal_mean_X_pa,...
            sys.state_dim,[]);
    end
end

%% Plotting and Monte-Carlo simulation-based validation
figure(1);
clf
box on;
hold on;
plot(safe_set.slice([3,4], slice_at_vx_vy), 'color', 'y');
plot(target_set.slice([3,4], slice_at_vx_vy), 'color', 'g');
scatter(initial_state(1),initial_state(2),200,'k^');
legend_cell = {'Safe set','Target set','Initial state'};
if exist('optimal_mean_trajectory_ft','var')
    scatter([initial_state(1), optimal_mean_trajectory_ft(1,:)],...
            [initial_state(2), optimal_mean_trajectory_ft(2,:)],...
            30, 'ro', 'filled');
    legend_cell{end+1} = 'Optimal mean trajectory (genzps-open)';
end
if exist('optimal_mean_trajectory_cc_pwl','var')
    scatter([initial_state(1), optimal_mean_trajectory_cc_pwl(1,:)],...
        [initial_state(2), optimal_mean_trajectory_cc_pwl(2,:)],...
        30, 'mo', 'filled');
    legend_cell{end+1} = 'Optimal mean trajectory (chance-open)';
end
if exist('optimal_mean_trajectory_pa','var')
    scatter([initial_state(1), optimal_mean_trajectory_pa(1,:)],...
        [initial_state(2), optimal_mean_trajectory_pa(2,:)],...
        30, 'ko', 'filled');
    legend_cell{end+1} = 'Optimal mean trajectory (particle-open)';
end
if exist('optimal_mean_trajectory_cc_affine','var')
    scatter([initial_state(1), optimal_mean_trajectory_cc_affine(1,:)],...
        [initial_state(2), optimal_mean_trajectory_cc_affine(2,:)],...
        30, 'bo', 'filled');
    legend_cell{end+1} = 'Optimal mean trajectory (chance-affine)';
end
legend(legend_cell, 'Location','South');
xlabel('$x$','interpreter','latex');
ylabel('$y$','interpreter','latex');

figure(2);
clf
box on;
hold on;
plot(safe_set.slice([3,4], slice_at_vx_vy), 'color', 'y');
plot(target_set.slice([3,4], slice_at_vx_vy), 'color', 'g');
scatter(initial_state(1),initial_state(2),200,'k^');
legend_cell = {'Safe set','Target set','Initial state'};
if exist('optimal_mean_trajectory_ft','var')
    scatter([initial_state(1), optimal_mean_trajectory_ft(1,:)],...
            [initial_state(2), optimal_mean_trajectory_ft(2,:)],...
            30, 'ro', 'filled');
    legend_cell{end+1} = 'Optimal mean trajectory (genzps-open)';
    if ~isnan(concat_state_realization_ft)
        if plot_traj_instead_of_ellipses == 1
            [legend_cell] = plotMonteCarlo('(genzps-open)', mcarlo_result_ft,...
                concat_state_realization_ft, n_mcarlo_sims, n_sims_to_plot,...
                sys.state_dim, initial_state, legend_cell);
        else
            ellipsoidsFromMonteCarloSims(concat_state_realization_ft,...
                sys.state_dim, [1,2], {'r'});
        end
    end
else
    lb_stoch_reach_avoid_ft = NaN;
    mcarlo_result_ft = NaN;
    elapsed_time_ft = NaN;     
end
if exist('optimal_mean_trajectory_cc_pwl','var')
    scatter([initial_state(1), optimal_mean_trajectory_cc_pwl(1,:)],...
        [initial_state(2), optimal_mean_trajectory_cc_pwl(2,:)],...
        30, 'mo', 'filled');
    legend_cell{end+1} = 'Optimal mean trajectory (chance-open)';
    if ~isnan(concat_state_realization_cc_pwl)
        if plot_traj_instead_of_ellipses == 1
            [legend_cell] = plotMonteCarlo('(chance-open)', ...
                mcarlo_result_cc_pwl, concat_state_realization_cc_pwl,...
                n_mcarlo_sims, n_sims_to_plot, sys.state_dim, initial_state,...
                legend_cell);
        else
            ellipsoidsFromMonteCarloSims(concat_state_realization_cc_pwl,...
                sys.state_dim, [1,2], {'m'});
        end
    end
else
    lb_stoch_reach_avoid_cc_pwl = NaN;
    mcarlo_result_cc_pwl = NaN;
    elapsed_time_cc_pwl = NaN;     
end
if exist('optimal_mean_trajectory_pa','var')
    scatter([initial_state(1), optimal_mean_trajectory_pa(1,:)],...
        [initial_state(2), optimal_mean_trajectory_pa(2,:)],...
        30, 'ko', 'filled');
    legend_cell{end+1} = 'Optimal mean trajectory (particle-open)';
    if ~isnan(concat_state_realization_pa)
        if plot_traj_instead_of_ellipses == 1
            [legend_cell] = plotMonteCarlo('(particle-open)', ...
                mcarlo_result_pa, concat_state_realization_pa,...
                n_mcarlo_sims, n_sims_to_plot, sys.state_dim, initial_state,...
                legend_cell);
        else
            ellipsoidsFromMonteCarloSims(concat_state_realization_pa,...
                sys.state_dim, [1,2], {'k'});
        end
    end
else
    lb_stoch_reach_avoid_pa = NaN;
    mcarlo_result_pa = NaN;
    elapsed_time_pa = NaN;     
end

if exist('optimal_mean_trajectory_cc_affine','var')
        scatter([initial_state(1), optimal_mean_trajectory_cc_affine(1,:)],...
        [initial_state(2), optimal_mean_trajectory_cc_affine(2,:)],...
        30, 'bd', 'filled');
    legend_cell{end+1} = 'Optimal mean trajectory (chance-affine)';
    if ~isnan(concat_state_realization_cc_affine)
        if plot_traj_instead_of_ellipses==1
            [legend_cell] = plotMonteCarlo('(chance-affine)',...
                mcarlo_result_cc_affine,...
                concat_state_realization_cc_affine, n_mcarlo_sims,...
                n_sims_to_plot, sys.state_dim, initial_state, legend_cell);
        else
            ellipsoidsFromMonteCarloSims(concat_state_realization_cc_affine,...
                sys.state_dim, [1,2], {'b'});
        end
    end
else
    lb_stoch_reach_avoid_cc_affine = NaN;
    mcarlo_result_cc_affine = NaN;
    elapsed_time_cc_affine = NaN;     
end
legend(legend_cell, 'Location','South');
if plot_traj_instead_of_ellipses==1
    title(sprintf('Plot with %d Monte-Carlo sims', n_sims_to_plot));
else
    title('Plot with ellipsoid fit for 100 randomly chosen Monte-Carlo sims');
end
box on;
grid on;
xlabel('$x$','interpreter','latex');
ylabel('$y$','interpreter','latex');
%% Reporting the results
if any(isnan([lb_stoch_reach_avoid_cc_pwl, lb_stoch_reach_avoid_ft,...
        lb_stoch_reach_avoid_cc_affine, lb_stoch_reach_avoid_pa]))
    disp('Skipped items would show up as NaN');
end
fprintf(['FT: %1.3f | CC (Open): %1.3f | Scenario (Open): %1.3f | ',...
    'CC (Affine): %1.3f\n'],...
    lb_stoch_reach_avoid_ft,...
    lb_stoch_reach_avoid_cc_pwl,...
    lb_stoch_reach_avoid_pa,...
    lb_stoch_reach_avoid_cc_affine); 
fprintf('MC (%1.0e particles): %1.3f, %1.3f, %1.3f, %1.3f\n',...
    n_mcarlo_sims,...
    sum(mcarlo_result_ft)/n_mcarlo_sims, ...
    sum(mcarlo_result_cc_pwl)/n_mcarlo_sims,...
    sum(mcarlo_result_pa)/n_mcarlo_sims,...
    sum(mcarlo_result_cc_affine)/n_mcarlo_sims);
fprintf('Elapsed time: %1.3f, %1.3f, %1.3f, %1.3f seconds\n',...
    elapsed_time_ft, elapsed_time_cc_pwl, elapsed_time_pa,...
    elapsed_time_cc_affine);

%% Helper functions
% Plotting function
function [legend_cell] = plotMonteCarlo(method_str, mcarlo_result,...
    concat_state_realization, n_mcarlo_sims, n_sims_to_plot, state_dim,...
    initial_state, legend_cell)
% Plots a selection of Monte-Carlo simulations on top of the plot

    green_legend_updated = 0;
    red_legend_updated = 0;
    traj_indices = floor(n_mcarlo_sims*rand(1,n_sims_to_plot));
    for realization_index = traj_indices
        % Check if the trajectory satisfies the reach-avoid objective
        if mcarlo_result(realization_index)
            % Assign green triangle as the marker
            markerString = 'g^-';
        else
            % Assign red asterisk as the marker
            markerString = 'r*-';
        end
        % Create [x(t_1) x(t_2)... x(t_N)]
        reshaped_X_vector = reshape(...
            concat_state_realization(:,realization_index), state_dim,[]);
        % This realization is to be plotted
        h = plot([initial_state(1), reshaped_X_vector(1,:)], ...
                 [initial_state(2), reshaped_X_vector(2,:)], ...
                 markerString, 'MarkerSize',10);
        % Update the legends if the first else, disable
        if strcmp(markerString,'g^-')
            if green_legend_updated
                h.Annotation.LegendInformation.IconDisplayStyle = 'off';
            else
                green_legend_updated = 1;
                legend_cell{end+1} = strcat('Good trajectory ', method_str);
            end
        elseif strcmp(markerString,'r*-')
            if red_legend_updated
                h.Annotation.LegendInformation.IconDisplayStyle = 'off';
            else
                red_legend_updated = 1;
                legend_cell{end+1} = strcat('Bad trajectory ', method_str);
            end
        end
    end
end

##### SOURCE END #####
--></body></html>